0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #ifndef __ASSEMBLER__
0211 
0212 static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
0213 static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }
0214 
0215 #endif
0216 
0217 #define V2P(a) (((uint) (a)) - KERNBASE)
0218 #define P2V(a) (((void *) (a)) + KERNBASE)
0219 
0220 #define V2P_WO(x) ((x) - KERNBASE)    
0221 #define P2V_WO(x) ((x) + KERNBASE)    
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct stat;
0259 struct superblock;
0260 
0261 
0262 void            binit(void);
0263 struct buf*     bread(uint, uint);
0264 void            brelse(struct buf*);
0265 void            bwrite(struct buf*);
0266 
0267 
0268 void            consoleinit(void);
0269 void            cprintf(char*, ...);
0270 void            consoleintr(int(*)(void));
0271 void            panic(char*) __attribute__((noreturn));
0272 
0273 
0274 int             exec(char*, char**);
0275 
0276 
0277 struct file*    filealloc(void);
0278 void            fileclose(struct file*);
0279 struct file*    filedup(struct file*);
0280 void            fileinit(void);
0281 int             fileread(struct file*, char*, int n);
0282 int             filestat(struct file*, struct stat*);
0283 int             filewrite(struct file*, char*, int n);
0284 
0285 
0286 void            readsb(int dev, struct superblock *sb);
0287 int             dirlink(struct inode*, char*, uint);
0288 struct inode*   dirlookup(struct inode*, char*, uint*);
0289 struct inode*   ialloc(uint, short);
0290 struct inode*   idup(struct inode*);
0291 void            iinit(int dev);
0292 void            ilock(struct inode*);
0293 void            iput(struct inode*);
0294 void            iunlock(struct inode*);
0295 void            iunlockput(struct inode*);
0296 void            iupdate(struct inode*);
0297 int             namecmp(const char*, const char*);
0298 struct inode*   namei(char*);
0299 struct inode*   nameiparent(char*, char*);
0300 int             readi(struct inode*, char*, uint, uint);
0301 void            stati(struct inode*, struct stat*);
0302 int             writei(struct inode*, char*, uint, uint);
0303 
0304 
0305 void            ideinit(void);
0306 void            ideintr(void);
0307 void            iderw(struct buf*);
0308 
0309 
0310 void            ioapicenable(int irq, int cpu);
0311 extern uchar    ioapicid;
0312 void            ioapicinit(void);
0313 
0314 
0315 char*           kalloc(void);
0316 void            kfree(char*);
0317 void            kinit1(void*, void*);
0318 void            kinit2(void*, void*);
0319 
0320 
0321 void            kbdintr(void);
0322 
0323 
0324 void            cmostime(struct rtcdate *r);
0325 int             cpunum(void);
0326 extern volatile uint*    lapic;
0327 void            lapiceoi(void);
0328 void            lapicinit(void);
0329 void            lapicstartap(uchar, uint);
0330 void            microdelay(int);
0331 
0332 
0333 void            initlog(int dev);
0334 void            log_write(struct buf*);
0335 void            begin_op();
0336 void            end_op();
0337 
0338 
0339 extern int      ismp;
0340 int             mpbcpu(void);
0341 void            mpinit(void);
0342 void            mpstartthem(void);
0343 
0344 
0345 void            picenable(int);
0346 void            picinit(void);
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 struct proc*    copyproc(struct proc*);
0359 void            exit(void);
0360 int             fork(void);
0361 int             growproc(int);
0362 int             kill(int);
0363 void            pinit(void);
0364 void            procdump(void);
0365 void            scheduler(void) __attribute__((noreturn));
0366 void            sched(void);
0367 void            sleep(void*, struct spinlock*);
0368 void            userinit(void);
0369 int             wait(void);
0370 void            wakeup(void*);
0371 void            yield(void);
0372 
0373 
0374 void            swtch(struct context**, struct context*);
0375 
0376 
0377 void            acquire(struct spinlock*);
0378 void            getcallerpcs(void*, uint*);
0379 int             holding(struct spinlock*);
0380 void            initlock(struct spinlock*, char*);
0381 void            release(struct spinlock*);
0382 void            pushcli(void);
0383 void            popcli(void);
0384 
0385 
0386 int             memcmp(const void*, const void*, uint);
0387 void*           memmove(void*, const void*, uint);
0388 void*           memset(void*, int, uint);
0389 char*           safestrcpy(char*, const char*, int);
0390 int             strlen(const char*);
0391 int             strncmp(const char*, const char*, uint);
0392 char*           strncpy(char*, const char*, int);
0393 
0394 
0395 int             argint(int, int*);
0396 int             argptr(int, char**, int);
0397 int             argstr(int, char**);
0398 int             fetchint(uint, int*);
0399 int             fetchstr(uint, char**);
0400 void            syscall(void);
0401 
0402 
0403 void            timerinit(void);
0404 
0405 
0406 void            idtinit(void);
0407 extern uint     ticks;
0408 void            tvinit(void);
0409 extern struct spinlock tickslock;
0410 
0411 
0412 void            uartinit(void);
0413 void            uartintr(void);
0414 void            uartputc(int);
0415 
0416 
0417 void            seginit(void);
0418 void            kvmalloc(void);
0419 void            vmenable(void);
0420 pde_t*          setupkvm(void);
0421 char*           uva2ka(pde_t*, char*);
0422 int             allocuvm(pde_t*, uint, uint);
0423 int             deallocuvm(pde_t*, uint, uint);
0424 void            freevm(pde_t*);
0425 void            inituvm(pde_t*, char*, uint);
0426 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0427 pde_t*          copyuvm(pde_t*, uint);
0428 void            switchuvm(struct proc*);
0429 void            switchkvm(void);
0430 int             copyout(pde_t*, uint, void*, uint);
0431 void            clearpteu(pde_t *pgdir, char *uva);
0432 
0433 
0434 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0435 
0436 
0437 
0438 
0439 
0440 
0441 
0442 
0443 
0444 
0445 
0446 
0447 
0448 
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_E     0x4       
0667 #define STA_C     0x4       
0668 #define STA_W     0x2       
0669 #define STA_R     0x2       
0670 #define STA_A     0x1       
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_CF           0x00000001      
0705 #define FL_PF           0x00000004      
0706 #define FL_AF           0x00000010      
0707 #define FL_ZF           0x00000040      
0708 #define FL_SF           0x00000080      
0709 #define FL_TF           0x00000100      
0710 #define FL_IF           0x00000200      
0711 #define FL_DF           0x00000400      
0712 #define FL_OF           0x00000800      
0713 #define FL_IOPL_MASK    0x00003000      
0714 #define FL_IOPL_0       0x00000000      
0715 #define FL_IOPL_1       0x00001000      
0716 #define FL_IOPL_2       0x00002000      
0717 #define FL_IOPL_3       0x00003000      
0718 #define FL_NT           0x00004000      
0719 #define FL_RF           0x00010000      
0720 #define FL_VM           0x00020000      
0721 #define FL_AC           0x00040000      
0722 #define FL_VIF          0x00080000      
0723 #define FL_VIP          0x00100000      
0724 #define FL_ID           0x00200000      
0725 
0726 
0727 #define CR0_PE          0x00000001      
0728 #define CR0_MP          0x00000002      
0729 #define CR0_EM          0x00000004      
0730 #define CR0_TS          0x00000008      
0731 #define CR0_ET          0x00000010      
0732 #define CR0_NE          0x00000020      
0733 #define CR0_WP          0x00010000      
0734 #define CR0_AM          0x00040000      
0735 #define CR0_NW          0x20000000      
0736 #define CR0_CD          0x40000000      
0737 #define CR0_PG          0x80000000      
0738 
0739 #define CR4_PSE         0x00000010      
0740 
0741 #define SEG_KCODE 1  
0742 #define SEG_KDATA 2  
0743 #define SEG_KCPU  3  
0744 #define SEG_UCODE 4  
0745 #define SEG_UDATA 5  
0746 #define SEG_TSS   6  
0747 
0748 
0749 
0750 #ifndef __ASSEMBLER__
0751 
0752 struct segdesc {
0753   uint lim_15_0 : 16;  
0754   uint base_15_0 : 16; 
0755   uint base_23_16 : 8; 
0756   uint type : 4;       
0757   uint s : 1;          
0758   uint dpl : 2;        
0759   uint p : 1;          
0760   uint lim_19_16 : 4;  
0761   uint avl : 1;        
0762   uint rsv1 : 1;       
0763   uint db : 1;         
0764   uint g : 1;          
0765   uint base_31_24 : 8; 
0766 };
0767 
0768 
0769 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0770 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0771   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0772   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0773 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0774 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0775   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0776   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0777 #endif
0778 
0779 #define DPL_USER    0x3     
0780 
0781 
0782 #define STA_X       0x8     
0783 #define STA_E       0x4     
0784 #define STA_C       0x4     
0785 #define STA_W       0x2     
0786 #define STA_R       0x2     
0787 #define STA_A       0x1     
0788 
0789 
0790 #define STS_T16A    0x1     
0791 #define STS_LDT     0x2     
0792 #define STS_T16B    0x3     
0793 #define STS_CG16    0x4     
0794 #define STS_TG      0x5     
0795 #define STS_IG16    0x6     
0796 #define STS_TG16    0x7     
0797 #define STS_T32A    0x9     
0798 #define STS_T32B    0xB     
0799 #define STS_CG32    0xC     
0800 #define STS_IG32    0xE     
0801 #define STS_TG32    0xF     
0802 
0803 
0804 
0805 
0806 
0807 
0808 
0809 
0810 
0811 
0812 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0813 
0814 
0815 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0816 
0817 
0818 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0819 
0820 
0821 #define NPDENTRIES      1024    
0822 #define NPTENTRIES      1024    
0823 #define PGSIZE          4096    
0824 
0825 #define PGSHIFT         12      
0826 #define PTXSHIFT        12      
0827 #define PDXSHIFT        22      
0828 
0829 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0830 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0831 
0832 
0833 #define PTE_P           0x001   
0834 #define PTE_W           0x002   
0835 #define PTE_U           0x004   
0836 #define PTE_PWT         0x008   
0837 #define PTE_PCD         0x010   
0838 #define PTE_A           0x020   
0839 #define PTE_D           0x040   
0840 #define PTE_PS          0x080   
0841 #define PTE_MBZ         0x180   
0842 
0843 
0844 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0845 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0846 
0847 #ifndef __ASSEMBLER__
0848 typedef uint pte_t;
0849 
0850 
0851 struct taskstate {
0852   uint link;         
0853   uint esp0;         
0854   ushort ss0;        
0855   ushort padding1;
0856   uint *esp1;
0857   ushort ss1;
0858   ushort padding2;
0859   uint *esp2;
0860   ushort ss2;
0861   ushort padding3;
0862   void *cr3;         
0863   uint *eip;         
0864   uint eflags;
0865   uint eax;          
0866   uint ecx;
0867   uint edx;
0868   uint ebx;
0869   uint *esp;
0870   uint *ebp;
0871   uint esi;
0872   uint edi;
0873   ushort es;         
0874   ushort padding4;
0875   ushort cs;
0876   ushort padding5;
0877   ushort ss;
0878   ushort padding6;
0879   ushort ds;
0880   ushort padding7;
0881   ushort fs;
0882   ushort padding8;
0883   ushort gs;
0884   ushort padding9;
0885   ushort ldt;
0886   ushort padding10;
0887   ushort t;          
0888   ushort iomb;       
0889 };
0890 
0891 
0892 
0893 
0894 
0895 
0896 
0897 
0898 
0899 
0900 
0901 struct gatedesc {
0902   uint off_15_0 : 16;   
0903   uint cs : 16;         
0904   uint args : 5;        
0905   uint rsv1 : 3;        
0906   uint type : 4;        
0907   uint s : 1;           
0908   uint dpl : 2;         
0909   uint p : 1;           
0910   uint off_31_16 : 16;  
0911 };
0912 
0913 
0914 
0915 
0916 
0917 
0918 
0919 
0920 
0921 #define SETGATE(gate, istrap, sel, off, d)                \
0922 {                                                         \
0923   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0924   (gate).cs = (sel);                                      \
0925   (gate).args = 0;                                        \
0926   (gate).rsv1 = 0;                                        \
0927   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0928   (gate).s = 0;                                           \
0929   (gate).dpl = (d);                                       \
0930   (gate).p = 1;                                           \
0931   (gate).off_31_16 = (uint)(off) >> 16;                  \
0932 }
0933 
0934 #endif
0935 
0936 
0937 
0938 
0939 
0940 
0941 
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 
0951 
0952 #define ELF_MAGIC 0x464C457FU  
0953 
0954 
0955 struct elfhdr {
0956   uint magic;  
0957   uchar elf[12];
0958   ushort type;
0959   ushort machine;
0960   uint version;
0961   uint entry;
0962   uint phoff;
0963   uint shoff;
0964   uint flags;
0965   ushort ehsize;
0966   ushort phentsize;
0967   ushort phnum;
0968   ushort shentsize;
0969   ushort shnum;
0970   ushort shstrndx;
0971 };
0972 
0973 
0974 struct proghdr {
0975   uint type;
0976   uint off;
0977   uint vaddr;
0978   uint paddr;
0979   uint filesz;
0980   uint memsz;
0981   uint flags;
0982   uint align;
0983 };
0984 
0985 
0986 #define ELF_PROG_LOAD           1
0987 
0988 
0989 #define ELF_PROG_FLAG_EXEC      1
0990 #define ELF_PROG_FLAG_WRITE     2
0991 #define ELF_PROG_FLAG_READ      4
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 .p2align 2
1023 .text
1024 .globl multiboot_header
1025 multiboot_header:
1026   
1027   
1028   .long magic
1029   .long flags
1030   .long (-magic-flags)
1031 
1032 
1033 
1034 
1035 .globl _start
1036 _start = V2P_WO(entry)
1037 
1038 
1039 .globl entry
1040 entry:
1041   
1042   movl    %cr4, %eax
1043   orl     $(CR4_PSE), %eax
1044   movl    %eax, %cr4
1045   
1046   movl    $(V2P_WO(entrypgdir)), %eax
1047   movl    %eax, %cr3
1048   
1049   movl    %cr0, %eax
1050   orl     $(CR0_PG|CR0_WP), %eax
1051   movl    %eax, %cr0
1052 
1053   
1054   movl $(stack + KSTACKSIZE), %esp
1055 
1056   
1057   
1058   
1059   
1060   mov $main, %eax
1061   jmp *%eax
1062 
1063 .comm stack, KSTACKSIZE
1064 
1065 
1066 
1067 
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 
1122 
1123 .code16
1124 .globl start
1125 start:
1126   cli
1127 
1128   xorw    %ax,%ax
1129   movw    %ax,%ds
1130   movw    %ax,%es
1131   movw    %ax,%ss
1132 
1133   lgdt    gdtdesc
1134   movl    %cr0, %eax
1135   orl     $CR0_PE, %eax
1136   movl    %eax, %cr0
1137 
1138 
1139 
1140 
1141 
1142 
1143 
1144 
1145 
1146 
1147 
1148 
1149 
1150   ljmpl    $(SEG_KCODE<<3), $(start32)
1151 
1152 .code32
1153 start32:
1154   movw    $(SEG_KDATA<<3), %ax
1155   movw    %ax, %ds
1156   movw    %ax, %es
1157   movw    %ax, %ss
1158   movw    $0, %ax
1159   movw    %ax, %fs
1160   movw    %ax, %gs
1161 
1162   
1163   movl    %cr4, %eax
1164   orl     $(CR4_PSE), %eax
1165   movl    %eax, %cr4
1166   
1167   movl    (start-12), %eax
1168   movl    %eax, %cr3
1169   
1170   movl    %cr0, %eax
1171   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1172   movl    %eax, %cr0
1173 
1174   
1175   movl    (start-4), %esp
1176   
1177   call	 *(start-8)
1178 
1179   movw    $0x8a00, %ax
1180   movw    %ax, %dx
1181   outw    %ax, %dx
1182   movw    $0x8ae0, %ax
1183   outw    %ax, %dx
1184 spin:
1185   jmp     spin
1186 
1187 .p2align 2
1188 gdt:
1189   SEG_NULLASM
1190   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1191   SEG_ASM(STA_W, 0, 0xffffffff)
1192 
1193 
1194 gdtdesc:
1195   .word   (gdtdesc - gdt - 1)
1196   .long   gdt
1197 
1198 
1199 
1200 #include "types.h"
1201 #include "defs.h"
1202 #include "param.h"
1203 #include "memlayout.h"
1204 #include "mmu.h"
1205 #include "proc.h"
1206 #include "x86.h"
1207 
1208 static void startothers(void);
1209 static void mpmain(void)  __attribute__((noreturn));
1210 extern pde_t *kpgdir;
1211 extern char end[]; 
1212 
1213 
1214 
1215 
1216 int
1217 main(void)
1218 {
1219   kinit1(end, P2V(4*1024*1024)); 
1220   kvmalloc();      
1221   mpinit();        
1222   lapicinit();
1223   seginit();       
1224   cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
1225   picinit();       
1226   ioapicinit();    
1227   consoleinit();   
1228   uartinit();      
1229   pinit();         
1230   tvinit();        
1231   binit();         
1232   fileinit();      
1233   ideinit();       
1234   if(!ismp)
1235     timerinit();   
1236   startothers();   
1237   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1238   userinit();      
1239   
1240   mpmain();
1241 }
1242 
1243 
1244 
1245 
1246 
1247 
1248 
1249 
1250 
1251 static void
1252 mpenter(void)
1253 {
1254   switchkvm();
1255   seginit();
1256   lapicinit();
1257   mpmain();
1258 }
1259 
1260 
1261 static void
1262 mpmain(void)
1263 {
1264   cprintf("cpu%d: starting\n", cpu->id);
1265   idtinit();       
1266   xchg(&cpu->started, 1); 
1267   scheduler();     
1268 }
1269 
1270 pde_t entrypgdir[];  
1271 
1272 
1273 static void
1274 startothers(void)
1275 {
1276   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1277   uchar *code;
1278   struct cpu *c;
1279   char *stack;
1280 
1281   
1282   
1283   
1284   code = p2v(0x7000);
1285   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1286 
1287   for(c = cpus; c < cpus+ncpu; c++){
1288     if(c == cpus+cpunum())  
1289       continue;
1290 
1291     
1292     
1293     
1294     stack = kalloc();
1295     *(void**)(code-4) = stack + KSTACKSIZE;
1296     *(void**)(code-8) = mpenter;
1297     *(int**)(code-12) = (void *) v2p(entrypgdir);
1298 
1299     lapicstartap(c->id, v2p(code));
1300     
1301     while(c->started == 0)
1302       ;
1303   }
1304 }
1305 
1306 
1307 
1308 
1309 
1310 __attribute__((__aligned__(PGSIZE)))
1311 pde_t entrypgdir[NPDENTRIES] = {
1312   
1313   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1314   
1315   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1316 };
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 
1356 
1357 
1358 
1359 
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 
1403 
1404 
1405 
1406 
1407 
1408 
1409 
1410 
1411 
1412 
1413 
1414 
1415 
1416 
1417 
1418 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 
1453 
1454 
1455 
1456 
1457 
1458 
1459 
1460 
1461 
1462 
1463 
1464 
1465 
1466 
1467 
1468 
1469 
1470 
1471 
1472 
1473 
1474 
1475 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 struct spinlock {
1502   uint locked;       
1503 
1504   
1505   char *name;        
1506   struct cpu *cpu;   
1507   uint pcs[10];      
1508                      
1509 };
1510 
1511 
1512 
1513 
1514 
1515 
1516 
1517 
1518 
1519 
1520 
1521 
1522 
1523 
1524 
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 
1551 
1552 #include "types.h"
1553 #include "defs.h"
1554 #include "param.h"
1555 #include "x86.h"
1556 #include "memlayout.h"
1557 #include "mmu.h"
1558 #include "proc.h"
1559 #include "spinlock.h"
1560 
1561 void
1562 initlock(struct spinlock *lk, char *name)
1563 {
1564   lk->name = name;
1565   lk->locked = 0;
1566   lk->cpu = 0;
1567 }
1568 
1569 
1570 
1571 
1572 
1573 void
1574 acquire(struct spinlock *lk)
1575 {
1576   pushcli(); 
1577   if(holding(lk))
1578     panic("acquire");
1579 
1580   
1581   
1582   
1583   while(xchg(&lk->locked, 1) != 0)
1584     ;
1585 
1586   
1587   lk->cpu = cpu;
1588   getcallerpcs(&lk, lk->pcs);
1589 }
1590 
1591 
1592 
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 
1601 void
1602 release(struct spinlock *lk)
1603 {
1604   if(!holding(lk))
1605     panic("release");
1606 
1607   lk->pcs[0] = 0;
1608   lk->cpu = 0;
1609 
1610   
1611   
1612   
1613   
1614   
1615   
1616   
1617   
1618   
1619   xchg(&lk->locked, 0);
1620 
1621   popcli();
1622 }
1623 
1624 
1625 void
1626 getcallerpcs(void *v, uint pcs[])
1627 {
1628   uint *ebp;
1629   int i;
1630 
1631   ebp = (uint*)v - 2;
1632   for(i = 0; i < 10; i++){
1633     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1634       break;
1635     pcs[i] = ebp[1];     
1636     ebp = (uint*)ebp[0]; 
1637   }
1638   for(; i < 10; i++)
1639     pcs[i] = 0;
1640 }
1641 
1642 
1643 int
1644 holding(struct spinlock *lock)
1645 {
1646   return lock->locked && lock->cpu == cpu;
1647 }
1648 
1649 
1650 
1651 
1652 
1653 
1654 void
1655 pushcli(void)
1656 {
1657   int eflags;
1658 
1659   eflags = readeflags();
1660   cli();
1661   if(cpu->ncli++ == 0)
1662     cpu->intena = eflags & FL_IF;
1663 }
1664 
1665 void
1666 popcli(void)
1667 {
1668   if(readeflags()&FL_IF)
1669     panic("popcli - interruptible");
1670   if(--cpu->ncli < 0)
1671     panic("popcli");
1672   if(cpu->ncli == 0 && cpu->intena)
1673     sti();
1674 }
1675 
1676 
1677 
1678 
1679 
1680 
1681 
1682 
1683 
1684 
1685 
1686 
1687 
1688 
1689 
1690 
1691 
1692 
1693 
1694 
1695 
1696 
1697 
1698 
1699 
1700 #include "param.h"
1701 #include "types.h"
1702 #include "defs.h"
1703 #include "x86.h"
1704 #include "memlayout.h"
1705 #include "mmu.h"
1706 #include "proc.h"
1707 #include "elf.h"
1708 
1709 extern char data[];  
1710 pde_t *kpgdir;  
1711 struct segdesc gdt[NSEGS];
1712 
1713 
1714 
1715 void
1716 seginit(void)
1717 {
1718   struct cpu *c;
1719 
1720   
1721   
1722   
1723   
1724   c = &cpus[cpunum()];
1725   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1726   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1727   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1728   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1729 
1730   
1731   c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
1732 
1733   lgdt(c->gdt, sizeof(c->gdt));
1734   loadgs(SEG_KCPU << 3);
1735 
1736   
1737   cpu = c;
1738   proc = 0;
1739 }
1740 
1741 
1742 
1743 
1744 
1745 
1746 
1747 
1748 
1749 
1750 
1751 
1752 
1753 static pte_t *
1754 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1755 {
1756   pde_t *pde;
1757   pte_t *pgtab;
1758 
1759   pde = &pgdir[PDX(va)];
1760   if(*pde & PTE_P){
1761     pgtab = (pte_t*)p2v(PTE_ADDR(*pde));
1762   } else {
1763     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1764       return 0;
1765     
1766     memset(pgtab, 0, PGSIZE);
1767     
1768     
1769     
1770     *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;
1771   }
1772   return &pgtab[PTX(va)];
1773 }
1774 
1775 
1776 
1777 
1778 static int
1779 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1780 {
1781   char *a, *last;
1782   pte_t *pte;
1783 
1784   a = (char*)PGROUNDDOWN((uint)va);
1785   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1786   for(;;){
1787     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1788       return -1;
1789     if(*pte & PTE_P)
1790       panic("remap");
1791     *pte = pa | perm | PTE_P;
1792     if(a == last)
1793       break;
1794     a += PGSIZE;
1795     pa += PGSIZE;
1796   }
1797   return 0;
1798 }
1799 
1800 
1801 
1802 
1803 
1804 
1805 
1806 
1807 
1808 
1809 
1810 
1811 
1812 
1813 
1814 
1815 
1816 
1817 
1818 
1819 
1820 
1821 
1822 
1823 static struct kmap {
1824   void *virt;
1825   uint phys_start;
1826   uint phys_end;
1827   int perm;
1828 } kmap[] = {
1829  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1830  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1831  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1832  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1833 };
1834 
1835 
1836 pde_t*
1837 setupkvm(void)
1838 {
1839   pde_t *pgdir;
1840   struct kmap *k;
1841 
1842   if((pgdir = (pde_t*)kalloc()) == 0)
1843     return 0;
1844   memset(pgdir, 0, PGSIZE);
1845   if (p2v(PHYSTOP) > (void*)DEVSPACE)
1846     panic("PHYSTOP too high");
1847   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1848     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1849                 (uint)k->phys_start, k->perm) < 0)
1850       return 0;
1851   return pgdir;
1852 }
1853 
1854 
1855 
1856 void
1857 kvmalloc(void)
1858 {
1859   kpgdir = setupkvm();
1860   switchkvm();
1861 }
1862 
1863 
1864 
1865 void
1866 switchkvm(void)
1867 {
1868   lcr3(v2p(kpgdir));   
1869 }
1870 
1871 
1872 void
1873 switchuvm(struct proc *p)
1874 {
1875   pushcli();
1876   cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
1877   cpu->gdt[SEG_TSS].s = 0;
1878   cpu->ts.ss0 = SEG_KDATA << 3;
1879   cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
1880   ltr(SEG_TSS << 3);
1881   if(p->pgdir == 0)
1882     panic("switchuvm: no pgdir");
1883   lcr3(v2p(p->pgdir));  
1884   popcli();
1885 }
1886 
1887 
1888 
1889 
1890 
1891 
1892 
1893 
1894 
1895 
1896 
1897 
1898 
1899 
1900 
1901 
1902 void
1903 inituvm(pde_t *pgdir, char *init, uint sz)
1904 {
1905   char *mem;
1906 
1907   if(sz >= PGSIZE)
1908     panic("inituvm: more than a page");
1909   mem = kalloc();
1910   memset(mem, 0, PGSIZE);
1911   mappages(pgdir, 0, PGSIZE, v2p(mem), PTE_W|PTE_U);
1912   memmove(mem, init, sz);
1913 }
1914 
1915 
1916 
1917 int
1918 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1919 {
1920   uint i, pa, n;
1921   pte_t *pte;
1922 
1923   if((uint) addr % PGSIZE != 0)
1924     panic("loaduvm: addr must be page aligned");
1925   for(i = 0; i < sz; i += PGSIZE){
1926     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1927       panic("loaduvm: address should exist");
1928     pa = PTE_ADDR(*pte);
1929     if(sz - i < PGSIZE)
1930       n = sz - i;
1931     else
1932       n = PGSIZE;
1933     if(readi(ip, p2v(pa), offset+i, n) != n)
1934       return -1;
1935   }
1936   return 0;
1937 }
1938 
1939 
1940 
1941 
1942 
1943 
1944 
1945 
1946 
1947 
1948 
1949 
1950 
1951 
1952 int
1953 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1954 {
1955   char *mem;
1956   uint a;
1957 
1958   if(newsz >= KERNBASE)
1959     return 0;
1960   if(newsz < oldsz)
1961     return oldsz;
1962 
1963   a = PGROUNDUP(oldsz);
1964   for(; a < newsz; a += PGSIZE){
1965     mem = kalloc();
1966     if(mem == 0){
1967       cprintf("allocuvm out of memory\n");
1968       deallocuvm(pgdir, newsz, oldsz);
1969       return 0;
1970     }
1971     memset(mem, 0, PGSIZE);
1972     mappages(pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);
1973   }
1974   return newsz;
1975 }
1976 
1977 
1978 
1979 
1980 
1981 int
1982 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1983 {
1984   pte_t *pte;
1985   uint a, pa;
1986 
1987   if(newsz >= oldsz)
1988     return oldsz;
1989 
1990   a = PGROUNDUP(newsz);
1991   for(; a  < oldsz; a += PGSIZE){
1992     pte = walkpgdir(pgdir, (char*)a, 0);
1993     if(!pte)
1994       a += (NPTENTRIES - 1) * PGSIZE;
1995     else if((*pte & PTE_P) != 0){
1996       pa = PTE_ADDR(*pte);
1997       if(pa == 0)
1998         panic("kfree");
1999       char *v = p2v(pa);
2000       kfree(v);
2001       *pte = 0;
2002     }
2003   }
2004   return newsz;
2005 }
2006 
2007 
2008 
2009 void
2010 freevm(pde_t *pgdir)
2011 {
2012   uint i;
2013 
2014   if(pgdir == 0)
2015     panic("freevm: no pgdir");
2016   deallocuvm(pgdir, KERNBASE, 0);
2017   for(i = 0; i < NPDENTRIES; i++){
2018     if(pgdir[i] & PTE_P){
2019       char * v = p2v(PTE_ADDR(pgdir[i]));
2020       kfree(v);
2021     }
2022   }
2023   kfree((char*)pgdir);
2024 }
2025 
2026 
2027 
2028 void
2029 clearpteu(pde_t *pgdir, char *uva)
2030 {
2031   pte_t *pte;
2032 
2033   pte = walkpgdir(pgdir, uva, 0);
2034   if(pte == 0)
2035     panic("clearpteu");
2036   *pte &= ~PTE_U;
2037 }
2038 
2039 
2040 
2041 
2042 
2043 
2044 
2045 
2046 
2047 
2048 
2049 
2050 
2051 
2052 pde_t*
2053 copyuvm(pde_t *pgdir, uint sz)
2054 {
2055   pde_t *d;
2056   pte_t *pte;
2057   uint pa, i, flags;
2058   char *mem;
2059 
2060   if((d = setupkvm()) == 0)
2061     return 0;
2062   for(i = 0; i < sz; i += PGSIZE){
2063     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
2064       panic("copyuvm: pte should exist");
2065     if(!(*pte & PTE_P))
2066       panic("copyuvm: page not present");
2067     pa = PTE_ADDR(*pte);
2068     flags = PTE_FLAGS(*pte);
2069     if((mem = kalloc()) == 0)
2070       goto bad;
2071     memmove(mem, (char*)p2v(pa), PGSIZE);
2072     if(mappages(d, (void*)i, PGSIZE, v2p(mem), flags) < 0)
2073       goto bad;
2074   }
2075   return d;
2076 
2077 bad:
2078   freevm(d);
2079   return 0;
2080 }
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 
2094 
2095 
2096 
2097 
2098 
2099 
2100 
2101 char*
2102 uva2ka(pde_t *pgdir, char *uva)
2103 {
2104   pte_t *pte;
2105 
2106   pte = walkpgdir(pgdir, uva, 0);
2107   if((*pte & PTE_P) == 0)
2108     return 0;
2109   if((*pte & PTE_U) == 0)
2110     return 0;
2111   return (char*)p2v(PTE_ADDR(*pte));
2112 }
2113 
2114 
2115 
2116 
2117 int
2118 copyout(pde_t *pgdir, uint va, void *p, uint len)
2119 {
2120   char *buf, *pa0;
2121   uint n, va0;
2122 
2123   buf = (char*)p;
2124   while(len > 0){
2125     va0 = (uint)PGROUNDDOWN(va);
2126     pa0 = uva2ka(pgdir, (char*)va0);
2127     if(pa0 == 0)
2128       return -1;
2129     n = PGSIZE - (va - va0);
2130     if(n > len)
2131       n = len;
2132     memmove(pa0 + (va - va0), buf, n);
2133     len -= n;
2134     buf += n;
2135     va = va0 + PGSIZE;
2136   }
2137   return 0;
2138 }
2139 
2140 
2141 
2142 
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 
2151 
2152 
2153 
2154 
2155 
2156 
2157 
2158 
2159 
2160 
2161 
2162 
2163 
2164 
2165 
2166 
2167 
2168 
2169 
2170 
2171 
2172 
2173 
2174 
2175 
2176 
2177 
2178 
2179 
2180 
2181 
2182 
2183 
2184 
2185 
2186 
2187 
2188 
2189 
2190 
2191 
2192 
2193 
2194 
2195 
2196 
2197 
2198 
2199 
2200 
2201 
2202 
2203 
2204 
2205 
2206 
2207 
2208 
2209 
2210 
2211 
2212 
2213 
2214 
2215 
2216 
2217 
2218 
2219 
2220 
2221 
2222 
2223 
2224 
2225 
2226 
2227 
2228 
2229 
2230 
2231 
2232 
2233 
2234 
2235 
2236 
2237 
2238 
2239 
2240 
2241 
2242 
2243 
2244 
2245 
2246 
2247 
2248 
2249 
2250 
2251 
2252 
2253 
2254 
2255 
2256 
2257 
2258 
2259 
2260 
2261 
2262 
2263 
2264 
2265 
2266 
2267 
2268 
2269 
2270 
2271 
2272 
2273 
2274 
2275 
2276 
2277 
2278 
2279 
2280 
2281 
2282 
2283 
2284 
2285 
2286 
2287 
2288 
2289 
2290 
2291 
2292 
2293 
2294 
2295 
2296 
2297 
2298 
2299 
2300 
2301 #define NSEGS     7
2302 
2303 
2304 struct cpu {
2305   uchar id;                    
2306   struct context *scheduler;   
2307   struct taskstate ts;         
2308   struct segdesc gdt[NSEGS];   
2309   volatile uint started;       
2310   int ncli;                    
2311   int intena;                  
2312 
2313   
2314   struct cpu *cpu;
2315   struct proc *proc;           
2316 };
2317 
2318 extern struct cpu cpus[NCPU];
2319 extern int ncpu;
2320 
2321 
2322 
2323 
2324 
2325 
2326 
2327 
2328 
2329 extern struct cpu *cpu asm("%gs:0");       
2330 extern struct proc *proc asm("%gs:4");     
2331 
2332 
2333 
2334 
2335 
2336 
2337 
2338 
2339 
2340 
2341 
2342 
2343 struct context {
2344   uint edi;
2345   uint esi;
2346   uint ebx;
2347   uint ebp;
2348   uint eip;
2349 };
2350 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2351 
2352 
2353 struct proc {
2354   uint sz;                     
2355   pde_t* pgdir;                
2356   char *kstack;                
2357   enum procstate state;        
2358   int pid;                     
2359   struct proc *parent;         
2360   struct trapframe *tf;        
2361   struct context *context;     
2362   void *chan;                  
2363   int killed;                  
2364   struct file *ofile[NOFILE];  
2365   struct inode *cwd;           
2366   char name[16];               
2367   int etime, ctime, rtime;  
2368 };
2369 
2370 
2371 
2372 
2373 
2374 
2375 
2376 
2377 
2378 
2379 
2380 
2381 
2382 
2383 
2384 
2385 
2386 
2387 
2388 
2389 
2390 
2391 
2392 
2393 
2394 
2395 
2396 
2397 
2398 
2399 
2400 #include "types.h"
2401 #include "defs.h"
2402 #include "param.h"
2403 #include "memlayout.h"
2404 #include "mmu.h"
2405 #include "x86.h"
2406 #include "proc.h"
2407 #include "spinlock.h"
2408 
2409 struct {
2410   struct spinlock lock;
2411   struct proc proc[NPROC];
2412 } ptable;
2413 
2414 static struct proc *initproc;
2415 
2416 int nextpid = 1;
2417 extern void forkret(void);
2418 extern void trapret(void);
2419 
2420 static void wakeup1(void *chan);
2421 
2422 void
2423 pinit(void)
2424 {
2425   initlock(&ptable.lock, "ptable");
2426 }
2427 
2428 
2429 
2430 
2431 
2432 
2433 
2434 
2435 
2436 
2437 
2438 
2439 
2440 
2441 
2442 
2443 
2444 
2445 
2446 
2447 
2448 
2449 
2450 
2451 
2452 
2453 
2454 static struct proc*
2455 allocproc(void)
2456 {
2457   struct proc *p;
2458   char *sp;
2459 
2460   acquire(&ptable.lock);
2461   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2462     if(p->state == UNUSED)
2463       goto found;
2464   release(&ptable.lock);
2465   return 0;
2466 
2467 found:
2468   p->state = EMBRYO;
2469   p->pid = nextpid++;
2470   release(&ptable.lock);
2471 
2472   
2473   if((p->kstack = kalloc()) == 0){
2474     p->state = UNUSED;
2475     return 0;
2476   }
2477   sp = p->kstack + KSTACKSIZE;
2478 
2479   
2480   sp -= sizeof *p->tf;
2481   p->tf = (struct trapframe*)sp;
2482 
2483   
2484   
2485   sp -= 4;
2486   *(uint*)sp = (uint)trapret;
2487 
2488   sp -= sizeof *p->context;
2489   p->context = (struct context*)sp;
2490   memset(p->context, 0, sizeof *p->context);
2491   p->context->eip = (uint)forkret;
2492 
2493   return p;
2494 }
2495 
2496 
2497 
2498 
2499 
2500 
2501 void
2502 userinit(void)
2503 {
2504   struct proc *p;
2505   extern char _binary_initcode_start[], _binary_initcode_size[];
2506 
2507   p = allocproc();
2508   initproc = p;
2509   if((p->pgdir = setupkvm()) == 0)
2510     panic("userinit: out of memory?");
2511   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2512   p->sz = PGSIZE;
2513   memset(p->tf, 0, sizeof(*p->tf));
2514   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2515   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2516   p->tf->es = p->tf->ds;
2517   p->tf->ss = p->tf->ds;
2518   p->tf->eflags = FL_IF;
2519   p->tf->esp = PGSIZE;
2520   p->tf->eip = 0;  
2521 
2522   safestrcpy(p->name, "initcode", sizeof(p->name));
2523   p->cwd = namei("/");
2524 
2525   p->state = RUNNABLE;
2526 }
2527 
2528 
2529 
2530 int
2531 growproc(int n)
2532 {
2533   uint sz;
2534 
2535   sz = proc->sz;
2536   if(n > 0){
2537     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
2538       return -1;
2539   } else if(n < 0){
2540     if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
2541       return -1;
2542   }
2543   proc->sz = sz;
2544   switchuvm(proc);
2545   return 0;
2546 }
2547 
2548 
2549 
2550 
2551 
2552 
2553 int
2554 fork(void)
2555 {
2556   int i, pid;
2557   struct proc *np;
2558 
2559   
2560   if((np = allocproc()) == 0)
2561     return -1;
2562 
2563   
2564   if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
2565     kfree(np->kstack);
2566     np->kstack = 0;
2567     np->state = UNUSED;
2568     return -1;
2569   }
2570   np->ctime = (int)ticks;  
2571   np->rtime = 0;
2572   np->sz = proc->sz;
2573   np->parent = proc;
2574   *np->tf = *proc->tf;
2575 
2576   
2577   np->tf->eax = 0;
2578 
2579   for(i = 0; i < NOFILE; i++)
2580     if(proc->ofile[i])
2581       np->ofile[i] = filedup(proc->ofile[i]);
2582   np->cwd = idup(proc->cwd);
2583 
2584   safestrcpy(np->name, proc->name, sizeof(proc->name));
2585 
2586   pid = np->pid;
2587 
2588   
2589   acquire(&ptable.lock);
2590   np->state = RUNNABLE;
2591   release(&ptable.lock);
2592 
2593   return pid;
2594 }
2595 
2596 
2597 
2598 
2599 
2600 
2601 
2602 
2603 void
2604 exit(void)
2605 {
2606   struct proc *p;
2607   int fd;
2608   acquire(&tickslock);
2609   proc->etime = ticks;
2610   release(&tickslock);
2611   if(proc == initproc)
2612     panic("init exiting");
2613 
2614   
2615   for(fd = 0; fd < NOFILE; fd++){
2616     if(proc->ofile[fd]){
2617       fileclose(proc->ofile[fd]);
2618       proc->ofile[fd] = 0;
2619     }
2620   }
2621 
2622   begin_op();
2623   iput(proc->cwd);
2624   end_op();
2625   proc->cwd = 0;
2626 
2627   acquire(&ptable.lock);
2628 
2629   
2630   wakeup1(proc->parent);
2631 
2632   
2633   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2634     if(p->parent == proc){
2635       p->parent = initproc;
2636       if(p->state == ZOMBIE)
2637         wakeup1(initproc);
2638     }
2639   }
2640 
2641   
2642   proc->state = ZOMBIE;
2643   sched();
2644   panic("zombie exit");
2645 }
2646 
2647 
2648 
2649 
2650 
2651 
2652 int
2653 wait(void)
2654 {
2655   struct proc *p;
2656   int havekids, pid;
2657 
2658   acquire(&ptable.lock);
2659   for(;;){
2660     
2661     havekids = 0;
2662     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2663       if(p->parent != proc)
2664         continue;
2665       havekids = 1;
2666       if(p->state == ZOMBIE){
2667         
2668         pid = p->pid;
2669         kfree(p->kstack);
2670         p->kstack = 0;
2671         freevm(p->pgdir);
2672         p->state = UNUSED;
2673         p->pid = 0;
2674         p->parent = 0;
2675         p->name[0] = 0;
2676         p->killed = 0;
2677         release(&ptable.lock);
2678         return pid;
2679       }
2680     }
2681 
2682     
2683     if(!havekids || proc->killed){
2684       release(&ptable.lock);
2685       return -1;
2686     }
2687 
2688     
2689     sleep(proc, &ptable.lock);  
2690   }
2691 }
2692 
2693 
2694 
2695 
2696 
2697 
2698 
2699 
2700 
2701 
2702 
2703 
2704 
2705 
2706 
2707 void
2708 scheduler(void)
2709 {
2710   struct proc *p;
2711 
2712   for(;;){
2713     
2714     sti();
2715 
2716     
2717     acquire(&ptable.lock);
2718     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2719       if(p->state != RUNNABLE)
2720         continue;
2721 
2722       
2723       
2724       
2725       proc = p;
2726       switchuvm(p);
2727       p->state = RUNNING;
2728       swtch(&cpu->scheduler, proc->context);
2729       switchkvm();
2730 
2731       
2732       
2733       proc = 0;
2734     }
2735     release(&ptable.lock);
2736 
2737   }
2738 }
2739 
2740 
2741 
2742 
2743 
2744 
2745 
2746 
2747 
2748 
2749 
2750 
2751 
2752 void
2753 sched(void)
2754 {
2755   int intena;
2756 
2757   if(!holding(&ptable.lock))
2758     panic("sched ptable.lock");
2759   if(cpu->ncli != 1)
2760     panic("sched locks");
2761   if(proc->state == RUNNING)
2762     panic("sched running");
2763   if(readeflags()&FL_IF)
2764     panic("sched interruptible");
2765   intena = cpu->intena;
2766   swtch(&proc->context, cpu->scheduler);
2767   cpu->intena = intena;
2768 }
2769 
2770 
2771 void
2772 yield(void)
2773 {
2774   acquire(&ptable.lock);  
2775   proc->state = RUNNABLE;
2776   sched();
2777   release(&ptable.lock);
2778 }
2779 
2780 
2781 
2782 void
2783 forkret(void)
2784 {
2785   static int first = 1;
2786   
2787   release(&ptable.lock);
2788 
2789   if (first) {
2790     
2791     
2792     
2793     first = 0;
2794     iinit(ROOTDEV);
2795     initlog(ROOTDEV);
2796   }
2797 
2798   
2799 }
2800 
2801 
2802 void
2803 sleep(void *chan, struct spinlock *lk)
2804 {
2805   if(proc == 0)
2806     panic("sleep");
2807 
2808   if(lk == 0)
2809     panic("sleep without lk");
2810 
2811   
2812   
2813   
2814   
2815   
2816   
2817   if(lk != &ptable.lock){  
2818     acquire(&ptable.lock);  
2819     release(lk);
2820   }
2821 
2822   
2823   proc->chan = chan;
2824   proc->state = SLEEPING;
2825   sched();
2826 
2827   
2828   proc->chan = 0;
2829 
2830   
2831   if(lk != &ptable.lock){  
2832     release(&ptable.lock);
2833     acquire(lk);
2834   }
2835 }
2836 
2837 
2838 
2839 
2840 
2841 
2842 
2843 
2844 
2845 
2846 
2847 
2848 
2849 
2850 
2851 
2852 static void
2853 wakeup1(void *chan)
2854 {
2855   struct proc *p;
2856 
2857   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2858     if(p->state == SLEEPING && p->chan == chan)
2859       p->state = RUNNABLE;
2860 }
2861 
2862 
2863 void
2864 wakeup(void *chan)
2865 {
2866   acquire(&ptable.lock);
2867   wakeup1(chan);
2868   release(&ptable.lock);
2869 }
2870 
2871 
2872 
2873 
2874 int
2875 kill(int pid)
2876 {
2877   struct proc *p;
2878 
2879   acquire(&ptable.lock);
2880   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2881     if(p->pid == pid){
2882       p->killed = 1;
2883 	  acquire(&tickslock);
2884 	  p->etime = ticks;
2885 	  release(&tickslock);
2886       
2887       if(p->state == SLEEPING)
2888         p->state = RUNNABLE;
2889       release(&ptable.lock);
2890       return 0;
2891     }
2892   }
2893   release(&ptable.lock);
2894   return -1;
2895 }
2896 
2897 
2898 
2899 
2900 
2901 
2902 
2903 void
2904 procdump(void)
2905 {
2906   static char *states[] = {
2907   [UNUSED]    "unused",
2908   [EMBRYO]    "embryo",
2909   [SLEEPING]  "sleep ",
2910   [RUNNABLE]  "runble",
2911   [RUNNING]   "run   ",
2912   [ZOMBIE]    "zombie"
2913   };
2914   int i;
2915   struct proc *p;
2916   char *state;
2917   uint pc[10];
2918 
2919   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2920     if(p->state == UNUSED)
2921       continue;
2922     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
2923       state = states[p->state];
2924     else
2925       state = "???";
2926     cprintf("%d %s %s", p->pid, state, p->name);
2927     if(p->state == SLEEPING){
2928       getcallerpcs((uint*)p->context->ebp+2, pc);
2929       for(i=0; i<10 && pc[i] != 0; i++)
2930         cprintf(" %p", pc[i]);
2931     }
2932     cprintf("\n");
2933   }
2934 }
2935 
2936 
2937 
2938 
2939 
2940 
2941 
2942 
2943 
2944 
2945 
2946 
2947 
2948 
2949 
2950 
2951 
2952 
2953 
2954 
2955 
2956 
2957 .globl swtch
2958 swtch:
2959   movl 4(%esp), %eax
2960   movl 8(%esp), %edx
2961 
2962   
2963   pushl %ebp
2964   pushl %ebx
2965   pushl %esi
2966   pushl %edi
2967 
2968   
2969   movl %esp, (%eax)
2970   movl %edx, %esp
2971 
2972   
2973   popl %edi
2974   popl %esi
2975   popl %ebx
2976   popl %ebp
2977   ret
2978 
2979 
2980 
2981 
2982 
2983 
2984 
2985 
2986 
2987 
2988 
2989 
2990 
2991 
2992 
2993 
2994 
2995 
2996 
2997 
2998 
2999 
3000 
3001 
3002 
3003 
3004 #include "types.h"
3005 #include "defs.h"
3006 #include "param.h"
3007 #include "memlayout.h"
3008 #include "mmu.h"
3009 #include "spinlock.h"
3010 
3011 void freerange(void *vstart, void *vend);
3012 extern char end[]; 
3013 
3014 struct run {
3015   struct run *next;
3016 };
3017 
3018 struct {
3019   struct spinlock lock;
3020   int use_lock;
3021   struct run *freelist;
3022 } kmem;
3023 
3024 
3025 
3026 
3027 
3028 
3029 void
3030 kinit1(void *vstart, void *vend)
3031 {
3032   initlock(&kmem.lock, "kmem");
3033   kmem.use_lock = 0;
3034   freerange(vstart, vend);
3035 }
3036 
3037 void
3038 kinit2(void *vstart, void *vend)
3039 {
3040   freerange(vstart, vend);
3041   kmem.use_lock = 1;
3042 }
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 void
3051 freerange(void *vstart, void *vend)
3052 {
3053   char *p;
3054   p = (char*)PGROUNDUP((uint)vstart);
3055   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
3056     kfree(p);
3057 }
3058 
3059 
3060 
3061 
3062 
3063 
3064 void
3065 kfree(char *v)
3066 {
3067   struct run *r;
3068 
3069   if((uint)v % PGSIZE || v < end || v2p(v) >= PHYSTOP)
3070     panic("kfree");
3071 
3072   
3073   memset(v, 1, PGSIZE);
3074 
3075   if(kmem.use_lock)
3076     acquire(&kmem.lock);
3077   r = (struct run*)v;
3078   r->next = kmem.freelist;
3079   kmem.freelist = r;
3080   if(kmem.use_lock)
3081     release(&kmem.lock);
3082 }
3083 
3084 
3085 
3086 
3087 char*
3088 kalloc(void)
3089 {
3090   struct run *r;
3091 
3092   if(kmem.use_lock)
3093     acquire(&kmem.lock);
3094   r = kmem.freelist;
3095   if(r)
3096     kmem.freelist = r->next;
3097   if(kmem.use_lock)
3098     release(&kmem.lock);
3099   return (char*)r;
3100 }
3101 
3102 
3103 
3104 
3105 
3106 
3107 
3108 
3109 
3110 
3111 
3112 
3113 
3114 
3115 
3116 
3117 
3118 
3119 
3120 
3121 
3122 
3123 
3124 
3125 
3126 
3127 
3128 
3129 
3130 
3131 
3132 
3133 
3134 
3135 
3136 
3137 
3138 
3139 
3140 
3141 
3142 
3143 
3144 
3145 
3146 
3147 
3148 
3149 
3150 
3151 
3152 
3153 #define T_DIVIDE         0      
3154 #define T_DEBUG          1      
3155 #define T_NMI            2      
3156 #define T_BRKPT          3      
3157 #define T_OFLOW          4      
3158 #define T_BOUND          5      
3159 #define T_ILLOP          6      
3160 #define T_DEVICE         7      
3161 #define T_DBLFLT         8      
3162 
3163 #define T_TSS           10      
3164 #define T_SEGNP         11      
3165 #define T_STACK         12      
3166 #define T_GPFLT         13      
3167 #define T_PGFLT         14      
3168 
3169 #define T_FPERR         16      
3170 #define T_ALIGN         17      
3171 #define T_MCHK          18      
3172 #define T_SIMDERR       19      
3173 
3174 
3175 
3176 #define T_SYSCALL       64      
3177 #define T_DEFAULT      500      
3178 
3179 #define T_IRQ0          32      
3180 
3181 #define IRQ_TIMER        0
3182 #define IRQ_KBD          1
3183 #define IRQ_COM1         4
3184 #define IRQ_IDE         14
3185 #define IRQ_ERROR       19
3186 #define IRQ_SPURIOUS    31
3187 
3188 
3189 
3190 
3191 
3192 
3193 
3194 
3195 
3196 
3197 
3198 
3199 
3200 #!/usr/bin/perl -w
3201 
3202 # Generate vectors.S, the trap/interrupt entry points.
3203 # There has to be one entry point per interrupt number
3204 # since otherwise there's no way for trap() to discover
3205 # the interrupt number.
3206 
3207 print "# generated by vectors.pl - do not edit\n";
3208 print "# handlers\n";
3209 print ".globl alltraps\n";
3210 for(my $i = 0; $i < 256; $i++){
3211     print ".globl vector$i\n";
3212     print "vector$i:\n";
3213     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
3214         print "  pushl \$0\n";
3215     }
3216     print "  pushl \$$i\n";
3217     print "  jmp alltraps\n";
3218 }
3219 
3220 print "\n# vector table\n";
3221 print ".data\n";
3222 print ".globl vectors\n";
3223 print "vectors:\n";
3224 for(my $i = 0; $i < 256; $i++){
3225     print "  .long vector$i\n";
3226 }
3227 
3228 # sample output:
3229 #   # handlers
3230 #   .globl alltraps
3231 #   .globl vector0
3232 #   vector0:
3233 #     pushl $0
3234 #     pushl $0
3235 #     jmp alltraps
3236 #   ...
3237 #
3238 #   # vector table
3239 #   .data
3240 #   .globl vectors
3241 #   vectors:
3242 #     .long vector0
3243 #     .long vector1
3244 #     .long vector2
3245 #   ...
3246 
3247 
3248 
3249 
3250 
3251 
3252   
3253 .globl alltraps
3254 alltraps:
3255   
3256   pushl %ds
3257   pushl %es
3258   pushl %fs
3259   pushl %gs
3260   pushal
3261 
3262   
3263   movw $(SEG_KDATA<<3), %ax
3264   movw %ax, %ds
3265   movw %ax, %es
3266   movw $(SEG_KCPU<<3), %ax
3267   movw %ax, %fs
3268   movw %ax, %gs
3269 
3270   
3271   pushl %esp
3272   call trap
3273   addl $4, %esp
3274 
3275   
3276 .globl trapret
3277 trapret:
3278   popal
3279   popl %gs
3280   popl %fs
3281   popl %es
3282   popl %ds
3283   addl $0x8, %esp  
3284   iret
3285 
3286 
3287 
3288 
3289 
3290 
3291 
3292 
3293 
3294 
3295 
3296 
3297 
3298 
3299 
3300 #include "types.h"
3301 #include "defs.h"
3302 #include "param.h"
3303 #include "memlayout.h"
3304 #include "mmu.h"
3305 #include "proc.h"
3306 #include "x86.h"
3307 #include "traps.h"
3308 #include "spinlock.h"
3309 
3310 
3311 struct gatedesc idt[256];
3312 extern uint vectors[];  
3313 struct spinlock tickslock;
3314 uint ticks;
3315 
3316 void
3317 tvinit(void)
3318 {
3319   int i;
3320 
3321   for(i = 0; i < 256; i++)
3322     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3323   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3324 
3325   initlock(&tickslock, "time");
3326 }
3327 
3328 void
3329 idtinit(void)
3330 {
3331   lidt(idt, sizeof(idt));
3332 }
3333 
3334 
3335 
3336 
3337 
3338 
3339 
3340 
3341 
3342 
3343 
3344 
3345 
3346 
3347 
3348 
3349 
3350 void
3351 trap(struct trapframe *tf)
3352 {
3353   if(tf->trapno == T_SYSCALL){
3354     if(proc->killed)
3355       exit();
3356     proc->tf = tf;
3357     syscall();
3358     if(proc->killed)
3359       exit();
3360     return;
3361   }
3362 
3363   switch(tf->trapno){
3364   case T_IRQ0 + IRQ_TIMER:
3365     if(cpu->id == 0){
3366       acquire(&tickslock);
3367       ticks++;
3368       wakeup(&ticks);
3369       release(&tickslock);
3370     }
3371     lapiceoi();
3372     break;
3373   case T_IRQ0 + IRQ_IDE:
3374     ideintr();
3375     lapiceoi();
3376     break;
3377   case T_IRQ0 + IRQ_IDE+1:
3378     
3379     break;
3380   case T_IRQ0 + IRQ_KBD:
3381     kbdintr();
3382     lapiceoi();
3383     break;
3384   case T_IRQ0 + IRQ_COM1:
3385     uartintr();
3386     lapiceoi();
3387     break;
3388   case T_IRQ0 + 7:
3389   case T_IRQ0 + IRQ_SPURIOUS:
3390     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3391             cpu->id, tf->cs, tf->eip);
3392     lapiceoi();
3393     break;
3394 
3395 
3396 
3397 
3398 
3399 
3400   default:
3401     if(proc == 0 || (tf->cs&3) == 0){
3402       
3403       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3404               tf->trapno, cpu->id, tf->eip, rcr2());
3405       panic("trap");
3406     }
3407     
3408     cprintf("pid %d %s: trap %d err %d on cpu %d "
3409             "eip 0x%x addr 0x%x--kill proc\n",
3410             proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip,
3411             rcr2());
3412     proc->killed = 1;
3413   }
3414 
3415   
3416   
3417   
3418   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
3419     exit();
3420 
3421   
3422   
3423   if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER){
3424 	  if(proc && proc->state == RUNNING){
3425 		proc->rtime++;   
3426 	  }
3427     yield();
3428   }
3429 
3430   
3431   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
3432     exit();
3433 }
3434 
3435 
3436 
3437 
3438 
3439 
3440 
3441 
3442 
3443 
3444 
3445 
3446 
3447 
3448 
3449 
3450 
3451 #define SYS_fork    1
3452 #define SYS_exit    2
3453 #define SYS_wait    3
3454 #define SYS_pipe    4
3455 #define SYS_read    5
3456 #define SYS_kill    6
3457 #define SYS_exec    7
3458 #define SYS_fstat   8
3459 #define SYS_chdir   9
3460 #define SYS_dup    10
3461 #define SYS_getpid 11
3462 #define SYS_sbrk   12
3463 #define SYS_sleep  13
3464 #define SYS_uptime 14
3465 #define SYS_open   15
3466 #define SYS_write  16
3467 #define SYS_mknod  17
3468 #define SYS_unlink 18
3469 #define SYS_link   19
3470 #define SYS_mkdir  20
3471 #define SYS_close  21
3472 #define SYS_waitx  22
3473 
3474 
3475 
3476 
3477 
3478 
3479 
3480 
3481 
3482 
3483 
3484 
3485 
3486 
3487 
3488 
3489 
3490 
3491 
3492 
3493 
3494 
3495 
3496 
3497 
3498 
3499 
3500 #include "types.h"
3501 #include "defs.h"
3502 #include "param.h"
3503 #include "memlayout.h"
3504 #include "mmu.h"
3505 #include "proc.h"
3506 #include "x86.h"
3507 #include "syscall.h"
3508 
3509 
3510 
3511 
3512 
3513 
3514 
3515 
3516 int
3517 fetchint(uint addr, int *ip)
3518 {
3519   if(addr >= proc->sz || addr+4 > proc->sz)
3520     return -1;
3521   *ip = *(int*)(addr);
3522   return 0;
3523 }
3524 
3525 
3526 
3527 
3528 int
3529 fetchstr(uint addr, char **pp)
3530 {
3531   char *s, *ep;
3532 
3533   if(addr >= proc->sz)
3534     return -1;
3535   *pp = (char*)addr;
3536   ep = (char*)proc->sz;
3537   for(s = *pp; s < ep; s++)
3538     if(*s == 0)
3539       return s - *pp;
3540   return -1;
3541 }
3542 
3543 
3544 int
3545 argint(int n, int *ip)
3546 {
3547   return fetchint(proc->tf->esp + 4 + 4*n, ip);
3548 }
3549 
3550 
3551 
3552 
3553 int
3554 argptr(int n, char **pp, int size)
3555 {
3556   int i;
3557 
3558   if(argint(n, &i) < 0)
3559     return -1;
3560   if((uint)i >= proc->sz || (uint)i+size > proc->sz)
3561     return -1;
3562   *pp = (char*)i;
3563   return 0;
3564 }
3565 
3566 
3567 
3568 
3569 
3570 int
3571 argstr(int n, char **pp)
3572 {
3573   int addr;
3574   if(argint(n, &addr) < 0)
3575     return -1;
3576   return fetchstr(addr, pp);
3577 }
3578 
3579 extern int sys_chdir(void);
3580 extern int sys_close(void);
3581 extern int sys_dup(void);
3582 extern int sys_exec(void);
3583 extern int sys_exit(void);
3584 extern int sys_fork(void);
3585 extern int sys_fstat(void);
3586 extern int sys_getpid(void);
3587 extern int sys_kill(void);
3588 extern int sys_link(void);
3589 extern int sys_mkdir(void);
3590 extern int sys_mknod(void);
3591 extern int sys_open(void);
3592 extern int sys_pipe(void);
3593 extern int sys_read(void);
3594 extern int sys_sbrk(void);
3595 extern int sys_sleep(void);
3596 extern int sys_unlink(void);
3597 extern int sys_wait(void);
3598 extern int sys_write(void);
3599 extern int sys_uptime(void);
3600 extern int sys_waitx(void);
3601 
3602 static int (*syscalls[])(void) = {
3603 [SYS_fork]    sys_fork,
3604 [SYS_exit]    sys_exit,
3605 [SYS_wait]    sys_wait,
3606 [SYS_pipe]    sys_pipe,
3607 [SYS_read]    sys_read,
3608 [SYS_kill]    sys_kill,
3609 [SYS_exec]    sys_exec,
3610 [SYS_fstat]   sys_fstat,
3611 [SYS_chdir]   sys_chdir,
3612 [SYS_dup]     sys_dup,
3613 [SYS_getpid]  sys_getpid,
3614 [SYS_sbrk]    sys_sbrk,
3615 [SYS_sleep]   sys_sleep,
3616 [SYS_uptime]  sys_uptime,
3617 [SYS_open]    sys_open,
3618 [SYS_write]   sys_write,
3619 [SYS_mknod]   sys_mknod,
3620 [SYS_unlink]  sys_unlink,
3621 [SYS_link]    sys_link,
3622 [SYS_mkdir]   sys_mkdir,
3623 [SYS_close]   sys_close,
3624 [SYS_waitx]   sys_waitx,
3625 };
3626 
3627 void
3628 syscall(void)
3629 {
3630   int num;
3631 
3632   num = proc->tf->eax;
3633   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3634     proc->tf->eax = syscalls[num]();
3635   } else {
3636     cprintf("%d %s: unknown sys call %d\n",
3637             proc->pid, proc->name, num);
3638     proc->tf->eax = -1;
3639   }
3640 }
3641 
3642 
3643 
3644 
3645 
3646 
3647 
3648 
3649 
3650 #include "types.h"
3651 #include "x86.h"
3652 #include "defs.h"
3653 #include "date.h"
3654 #include "param.h"
3655 #include "memlayout.h"
3656 #include "mmu.h"
3657 #include "proc.h"
3658 
3659 int
3660 sys_fork(void)
3661 {
3662   return fork();
3663 }
3664 
3665 int
3666 sys_exit(void)
3667 {
3668   exit();
3669   return 0;  
3670 }
3671 
3672 int
3673 sys_wait(void)
3674 {
3675   return wait();
3676 }
3677 
3678 int
3679 sys_kill(void)
3680 {
3681   int pid;
3682 
3683   if(argint(0, &pid) < 0)
3684     return -1;
3685   return kill(pid);
3686 }
3687 
3688 int
3689 sys_getpid(void)
3690 {
3691   return proc->pid;
3692 }
3693 
3694 
3695 
3696 
3697 
3698 
3699 
3700 int
3701 sys_sbrk(void)
3702 {
3703   int addr;
3704   int n;
3705 
3706   if(argint(0, &n) < 0)
3707     return -1;
3708   addr = proc->sz;
3709   if(growproc(n) < 0)
3710     return -1;
3711   return addr;
3712 }
3713 
3714 int
3715 sys_sleep(void)
3716 {
3717   int n;
3718   uint ticks0;
3719 
3720   if(argint(0, &n) < 0)
3721     return -1;
3722   acquire(&tickslock);
3723   ticks0 = ticks;
3724   while(ticks - ticks0 < n){
3725     if(proc->killed){
3726       release(&tickslock);
3727       return -1;
3728     }
3729     sleep(&ticks, &tickslock);
3730   }
3731   release(&tickslock);
3732   return 0;
3733 }
3734 
3735 
3736 
3737 int
3738 sys_uptime(void)
3739 {
3740   uint xticks;
3741 
3742   acquire(&tickslock);
3743   xticks = ticks;
3744   release(&tickslock);
3745   return xticks;
3746 }
3747 
3748 
3749 
3750 int
3751 sys_waitx(void)
3752 {
3753   cprintf("pid of child is:%d\n", proc->pid);
3754   int status = wait();
3755   cprintf("pid of current process is:%d and its runtime is:%d\n", proc->pid, proc->rtime);
3756   int n1, n2;
3757   if((argint(0, &n1) < 0) && (argint(1, &n2) < 0)){
3758 	return -1;
3759   }
3760   *(int *)n1 = proc->rtime;
3761   acquire(&tickslock);
3762   *(int *)n2 = ticks - proc->ctime - proc->rtime;
3763   release(&tickslock);
3764   cprintf("create time is:%d etime is:%d rtime is:%d wait time is:%d\n", proc->ctime, proc->etime, proc->rtime, n2);
3765   return status;
3766 }
3767 
3768 
3769 
3770 
3771 
3772 
3773 
3774 
3775 
3776 
3777 
3778 
3779 
3780 
3781 
3782 
3783 
3784 
3785 
3786 
3787 
3788 
3789 
3790 
3791 
3792 
3793 
3794 
3795 
3796 
3797 
3798 
3799 
3800 struct buf {
3801   int flags;
3802   uint dev;
3803   uint blockno;
3804   struct buf *prev; 
3805   struct buf *next;
3806   struct buf *qnext; 
3807   uchar data[BSIZE];
3808 };
3809 #define B_BUSY  0x1  
3810 #define B_VALID 0x2  
3811 #define B_DIRTY 0x4  
3812 
3813 
3814 
3815 
3816 
3817 
3818 
3819 
3820 
3821 
3822 
3823 
3824 
3825 
3826 
3827 
3828 
3829 
3830 
3831 
3832 
3833 
3834 
3835 
3836 
3837 
3838 
3839 
3840 
3841 
3842 
3843 
3844 
3845 
3846 
3847 
3848 
3849 
3850 #define O_RDONLY  0x000
3851 #define O_WRONLY  0x001
3852 #define O_RDWR    0x002
3853 #define O_CREATE  0x200
3854 
3855 
3856 
3857 
3858 
3859 
3860 
3861 
3862 
3863 
3864 
3865 
3866 
3867 
3868 
3869 
3870 
3871 
3872 
3873 
3874 
3875 
3876 
3877 
3878 
3879 
3880 
3881 
3882 
3883 
3884 
3885 
3886 
3887 
3888 
3889 
3890 
3891 
3892 
3893 
3894 
3895 
3896 
3897 
3898 
3899 
3900 #define T_DIR  1   
3901 #define T_FILE 2   
3902 #define T_DEV  3   
3903 
3904 struct stat {
3905   short type;  
3906   int dev;     
3907   uint ino;    
3908   short nlink; 
3909   uint size;   
3910 };
3911 
3912 
3913 
3914 
3915 
3916 
3917 
3918 
3919 
3920 
3921 
3922 
3923 
3924 
3925 
3926 
3927 
3928 
3929 
3930 
3931 
3932 
3933 
3934 
3935 
3936 
3937 
3938 
3939 
3940 
3941 
3942 
3943 
3944 
3945 
3946 
3947 
3948 
3949 
3950 
3951 
3952 
3953 
3954 #define ROOTINO 1  
3955 #define BSIZE 512  
3956 
3957 
3958 
3959 
3960 
3961 
3962 struct superblock {
3963   uint size;         
3964   uint nblocks;      
3965   uint ninodes;      
3966   uint nlog;         
3967   uint logstart;     
3968   uint inodestart;   
3969   uint bmapstart;    
3970 };
3971 
3972 #define NDIRECT 12
3973 #define NINDIRECT (BSIZE / sizeof(uint))
3974 #define MAXFILE (NDIRECT + NINDIRECT)
3975 
3976 
3977 struct dinode {
3978   short type;           
3979   short major;          
3980   short minor;          
3981   short nlink;          
3982   uint size;            
3983   uint addrs[NDIRECT+1];   
3984 };
3985 
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 
4001 #define IPB           (BSIZE / sizeof(struct dinode))
4002 
4003 
4004 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
4005 
4006 
4007 #define BPB           (BSIZE*8)
4008 
4009 
4010 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
4011 
4012 
4013 #define DIRSIZ 14
4014 
4015 struct dirent {
4016   ushort inum;
4017   char name[DIRSIZ];
4018 };
4019 
4020 
4021 
4022 
4023 
4024 
4025 
4026 
4027 
4028 
4029 
4030 
4031 
4032 
4033 
4034 
4035 
4036 
4037 
4038 
4039 
4040 
4041 
4042 
4043 
4044 
4045 
4046 
4047 
4048 
4049 
4050 struct file {
4051   enum { FD_NONE, FD_PIPE, FD_INODE } type;
4052   int ref; 
4053   char readable;
4054   char writable;
4055   struct pipe *pipe;
4056   struct inode *ip;
4057   uint off;
4058 };
4059 
4060 
4061 
4062 struct inode {
4063   uint dev;           
4064   uint inum;          
4065   int ref;            
4066   int flags;          
4067 
4068   short type;         
4069   short major;
4070   short minor;
4071   short nlink;
4072   uint size;
4073   uint addrs[NDIRECT+1];
4074 };
4075 #define I_BUSY 0x1
4076 #define I_VALID 0x2
4077 
4078 
4079 
4080 struct devsw {
4081   int (*read)(struct inode*, char*, int);
4082   int (*write)(struct inode*, char*, int);
4083 };
4084 
4085 extern struct devsw devsw[];
4086 
4087 #define CONSOLE 1
4088 
4089 
4090 
4091 
4092 
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100 
4101 
4102 
4103 
4104 
4105 
4106 
4107 
4108 
4109 
4110 
4111 
4112 
4113 
4114 
4115 
4116 
4117 
4118 
4119 
4120 
4121 
4122 
4123 
4124 
4125 
4126 
4127 
4128 
4129 
4130 
4131 
4132 
4133 
4134 
4135 
4136 
4137 
4138 
4139 
4140 
4141 
4142 
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150 
4151 
4152 #include "types.h"
4153 #include "defs.h"
4154 #include "param.h"
4155 #include "memlayout.h"
4156 #include "mmu.h"
4157 #include "proc.h"
4158 #include "x86.h"
4159 #include "traps.h"
4160 #include "spinlock.h"
4161 #include "fs.h"
4162 #include "buf.h"
4163 
4164 #define SECTOR_SIZE   512
4165 #define IDE_BSY       0x80
4166 #define IDE_DRDY      0x40
4167 #define IDE_DF        0x20
4168 #define IDE_ERR       0x01
4169 
4170 #define IDE_CMD_READ  0x20
4171 #define IDE_CMD_WRITE 0x30
4172 
4173 
4174 
4175 
4176 
4177 static struct spinlock idelock;
4178 static struct buf *idequeue;
4179 
4180 static int havedisk1;
4181 static void idestart(struct buf*);
4182 
4183 
4184 static int
4185 idewait(int checkerr)
4186 {
4187   int r;
4188 
4189   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
4190     ;
4191   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
4192     return -1;
4193   return 0;
4194 }
4195 
4196 
4197 
4198 
4199 
4200 void
4201 ideinit(void)
4202 {
4203   int i;
4204 
4205   initlock(&idelock, "ide");
4206   picenable(IRQ_IDE);
4207   ioapicenable(IRQ_IDE, ncpu - 1);
4208   idewait(0);
4209 
4210   
4211   outb(0x1f6, 0xe0 | (1<<4));
4212   for(i=0; i<1000; i++){
4213     if(inb(0x1f7) != 0){
4214       havedisk1 = 1;
4215       break;
4216     }
4217   }
4218 
4219   
4220   outb(0x1f6, 0xe0 | (0<<4));
4221 }
4222 
4223 
4224 static void
4225 idestart(struct buf *b)
4226 {
4227   if(b == 0)
4228     panic("idestart");
4229   if(b->blockno >= FSSIZE)
4230     panic("incorrect blockno");
4231   int sector_per_block =  BSIZE/SECTOR_SIZE;
4232   int sector = b->blockno * sector_per_block;
4233 
4234   if (sector_per_block > 7) panic("idestart");
4235 
4236   idewait(0);
4237   outb(0x3f6, 0);  
4238   outb(0x1f2, sector_per_block);  
4239   outb(0x1f3, sector & 0xff);
4240   outb(0x1f4, (sector >> 8) & 0xff);
4241   outb(0x1f5, (sector >> 16) & 0xff);
4242   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
4243   if(b->flags & B_DIRTY){
4244     outb(0x1f7, IDE_CMD_WRITE);
4245     outsl(0x1f0, b->data, BSIZE/4);
4246   } else {
4247     outb(0x1f7, IDE_CMD_READ);
4248   }
4249 }
4250 
4251 void
4252 ideintr(void)
4253 {
4254   struct buf *b;
4255 
4256   
4257   acquire(&idelock);
4258   if((b = idequeue) == 0){
4259     release(&idelock);
4260     
4261     return;
4262   }
4263   idequeue = b->qnext;
4264 
4265   
4266   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
4267     insl(0x1f0, b->data, BSIZE/4);
4268 
4269   
4270   b->flags |= B_VALID;
4271   b->flags &= ~B_DIRTY;
4272   wakeup(b);
4273 
4274   
4275   if(idequeue != 0)
4276     idestart(idequeue);
4277 
4278   release(&idelock);
4279 }
4280 
4281 
4282 
4283 
4284 
4285 
4286 
4287 
4288 
4289 
4290 
4291 
4292 
4293 
4294 
4295 
4296 
4297 
4298 
4299 
4300 
4301 
4302 
4303 void
4304 iderw(struct buf *b)
4305 {
4306   struct buf **pp;
4307 
4308   if(!(b->flags & B_BUSY))
4309     panic("iderw: buf not busy");
4310   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4311     panic("iderw: nothing to do");
4312   if(b->dev != 0 && !havedisk1)
4313     panic("iderw: ide disk 1 not present");
4314 
4315   acquire(&idelock);  
4316 
4317   
4318   b->qnext = 0;
4319   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4320     ;
4321   *pp = b;
4322 
4323   
4324   if(idequeue == b)
4325     idestart(b);
4326 
4327   
4328   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4329     sleep(b, &idelock);
4330   }
4331 
4332   release(&idelock);
4333 }
4334 
4335 
4336 
4337 
4338 
4339 
4340 
4341 
4342 
4343 
4344 
4345 
4346 
4347 
4348 
4349 
4350 
4351 
4352 
4353 
4354 
4355 
4356 
4357 
4358 
4359 
4360 
4361 
4362 
4363 
4364 
4365 
4366 
4367 
4368 
4369 
4370 
4371 
4372 #include "types.h"
4373 #include "defs.h"
4374 #include "param.h"
4375 #include "spinlock.h"
4376 #include "fs.h"
4377 #include "buf.h"
4378 
4379 struct {
4380   struct spinlock lock;
4381   struct buf buf[NBUF];
4382 
4383   
4384   
4385   struct buf head;
4386 } bcache;
4387 
4388 void
4389 binit(void)
4390 {
4391   struct buf *b;
4392 
4393   initlock(&bcache.lock, "bcache");
4394 
4395 
4396 
4397 
4398 
4399 
4400   
4401   bcache.head.prev = &bcache.head;
4402   bcache.head.next = &bcache.head;
4403   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4404     b->next = bcache.head.next;
4405     b->prev = &bcache.head;
4406     b->dev = -1;
4407     bcache.head.next->prev = b;
4408     bcache.head.next = b;
4409   }
4410 }
4411 
4412 
4413 
4414 
4415 static struct buf*
4416 bget(uint dev, uint blockno)
4417 {
4418   struct buf *b;
4419 
4420   acquire(&bcache.lock);
4421 
4422  loop:
4423   
4424   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4425     if(b->dev == dev && b->blockno == blockno){
4426       if(!(b->flags & B_BUSY)){
4427         b->flags |= B_BUSY;
4428         release(&bcache.lock);
4429         return b;
4430       }
4431       sleep(b, &bcache.lock);
4432       goto loop;
4433     }
4434   }
4435 
4436   
4437   
4438   
4439   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4440     if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
4441       b->dev = dev;
4442       b->blockno = blockno;
4443       b->flags = B_BUSY;
4444       release(&bcache.lock);
4445       return b;
4446     }
4447   }
4448   panic("bget: no buffers");
4449 }
4450 
4451 struct buf*
4452 bread(uint dev, uint blockno)
4453 {
4454   struct buf *b;
4455 
4456   b = bget(dev, blockno);
4457   if(!(b->flags & B_VALID)) {
4458     iderw(b);
4459   }
4460   return b;
4461 }
4462 
4463 
4464 void
4465 bwrite(struct buf *b)
4466 {
4467   if((b->flags & B_BUSY) == 0)
4468     panic("bwrite");
4469   b->flags |= B_DIRTY;
4470   iderw(b);
4471 }
4472 
4473 
4474 
4475 void
4476 brelse(struct buf *b)
4477 {
4478   if((b->flags & B_BUSY) == 0)
4479     panic("brelse");
4480 
4481   acquire(&bcache.lock);
4482 
4483   b->next->prev = b->prev;
4484   b->prev->next = b->next;
4485   b->next = bcache.head.next;
4486   b->prev = &bcache.head;
4487   bcache.head.next->prev = b;
4488   bcache.head.next = b;
4489 
4490   b->flags &= ~B_BUSY;
4491   wakeup(b);
4492 
4493   release(&bcache.lock);
4494 }
4495 
4496 
4497 
4498 
4499 
4500 
4501 
4502 
4503 
4504 
4505 
4506 
4507 
4508 
4509 
4510 
4511 
4512 
4513 
4514 
4515 
4516 
4517 
4518 
4519 
4520 
4521 
4522 
4523 
4524 
4525 
4526 
4527 
4528 
4529 
4530 
4531 
4532 
4533 
4534 
4535 
4536 
4537 
4538 
4539 
4540 
4541 
4542 
4543 
4544 
4545 
4546 
4547 
4548 
4549 
4550 #include "types.h"
4551 #include "defs.h"
4552 #include "param.h"
4553 #include "spinlock.h"
4554 #include "fs.h"
4555 #include "buf.h"
4556 
4557 
4558 
4559 
4560 
4561 
4562 
4563 
4564 
4565 
4566 
4567 
4568 
4569 
4570 
4571 
4572 
4573 
4574 
4575 
4576 
4577 
4578 
4579 
4580 
4581 
4582 struct logheader {
4583   int n;
4584   int block[LOGSIZE];
4585 };
4586 
4587 struct log {
4588   struct spinlock lock;
4589   int start;
4590   int size;
4591   int outstanding; 
4592   int committing;  
4593   int dev;
4594   struct logheader lh;
4595 };
4596 
4597 
4598 
4599 
4600 struct log log;
4601 
4602 static void recover_from_log(void);
4603 static void commit();
4604 
4605 void
4606 initlog(int dev)
4607 {
4608   if (sizeof(struct logheader) >= BSIZE)
4609     panic("initlog: too big logheader");
4610 
4611   struct superblock sb;
4612   initlock(&log.lock, "log");
4613   readsb(dev, &sb);
4614   log.start = sb.logstart;
4615   log.size = sb.nlog;
4616   log.dev = dev;
4617   recover_from_log();
4618 }
4619 
4620 
4621 static void
4622 install_trans(void)
4623 {
4624   int tail;
4625 
4626   for (tail = 0; tail < log.lh.n; tail++) {
4627     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
4628     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
4629     memmove(dbuf->data, lbuf->data, BSIZE);  
4630     bwrite(dbuf);  
4631     brelse(lbuf);
4632     brelse(dbuf);
4633   }
4634 }
4635 
4636 
4637 static void
4638 read_head(void)
4639 {
4640   struct buf *buf = bread(log.dev, log.start);
4641   struct logheader *lh = (struct logheader *) (buf->data);
4642   int i;
4643   log.lh.n = lh->n;
4644   for (i = 0; i < log.lh.n; i++) {
4645     log.lh.block[i] = lh->block[i];
4646   }
4647   brelse(buf);
4648 }
4649 
4650 
4651 
4652 
4653 static void
4654 write_head(void)
4655 {
4656   struct buf *buf = bread(log.dev, log.start);
4657   struct logheader *hb = (struct logheader *) (buf->data);
4658   int i;
4659   hb->n = log.lh.n;
4660   for (i = 0; i < log.lh.n; i++) {
4661     hb->block[i] = log.lh.block[i];
4662   }
4663   bwrite(buf);
4664   brelse(buf);
4665 }
4666 
4667 static void
4668 recover_from_log(void)
4669 {
4670   read_head();
4671   install_trans(); 
4672   log.lh.n = 0;
4673   write_head(); 
4674 }
4675 
4676 
4677 void
4678 begin_op(void)
4679 {
4680   acquire(&log.lock);
4681   while(1){
4682     if(log.committing){
4683       sleep(&log, &log.lock);
4684     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
4685       
4686       sleep(&log, &log.lock);
4687     } else {
4688       log.outstanding += 1;
4689       release(&log.lock);
4690       break;
4691     }
4692   }
4693 }
4694 
4695 
4696 
4697 
4698 
4699 
4700 
4701 
4702 void
4703 end_op(void)
4704 {
4705   int do_commit = 0;
4706 
4707   acquire(&log.lock);
4708   log.outstanding -= 1;
4709   if(log.committing)
4710     panic("log.committing");
4711   if(log.outstanding == 0){
4712     do_commit = 1;
4713     log.committing = 1;
4714   } else {
4715     
4716     wakeup(&log);
4717   }
4718   release(&log.lock);
4719 
4720   if(do_commit){
4721     
4722     
4723     commit();
4724     acquire(&log.lock);
4725     log.committing = 0;
4726     wakeup(&log);
4727     release(&log.lock);
4728   }
4729 }
4730 
4731 
4732 static void
4733 write_log(void)
4734 {
4735   int tail;
4736 
4737   for (tail = 0; tail < log.lh.n; tail++) {
4738     struct buf *to = bread(log.dev, log.start+tail+1); 
4739     struct buf *from = bread(log.dev, log.lh.block[tail]); 
4740     memmove(to->data, from->data, BSIZE);
4741     bwrite(to);  
4742     brelse(from);
4743     brelse(to);
4744   }
4745 }
4746 
4747 
4748 
4749 
4750 static void
4751 commit()
4752 {
4753   if (log.lh.n > 0) {
4754     write_log();     
4755     write_head();    
4756     install_trans(); 
4757     log.lh.n = 0;
4758     write_head();    
4759   }
4760 }
4761 
4762 
4763 
4764 
4765 
4766 
4767 
4768 
4769 
4770 
4771 void
4772 log_write(struct buf *b)
4773 {
4774   int i;
4775 
4776   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
4777     panic("too big a transaction");
4778   if (log.outstanding < 1)
4779     panic("log_write outside of trans");
4780 
4781   acquire(&log.lock);
4782   for (i = 0; i < log.lh.n; i++) {
4783     if (log.lh.block[i] == b->blockno)   
4784       break;
4785   }
4786   log.lh.block[i] = b->blockno;
4787   if (i == log.lh.n)
4788     log.lh.n++;
4789   b->flags |= B_DIRTY; 
4790   release(&log.lock);
4791 }
4792 
4793 
4794 
4795 
4796 
4797 
4798 
4799 
4800 
4801 
4802 
4803 
4804 
4805 
4806 
4807 
4808 
4809 
4810 
4811 #include "types.h"
4812 #include "defs.h"
4813 #include "param.h"
4814 #include "stat.h"
4815 #include "mmu.h"
4816 #include "proc.h"
4817 #include "spinlock.h"
4818 #include "fs.h"
4819 #include "buf.h"
4820 #include "file.h"
4821 
4822 #define min(a, b) ((a) < (b) ? (a) : (b))
4823 static void itrunc(struct inode*);
4824 struct superblock sb;   
4825 
4826 
4827 void
4828 readsb(int dev, struct superblock *sb)
4829 {
4830   struct buf *bp;
4831 
4832   bp = bread(dev, 1);
4833   memmove(sb, bp->data, sizeof(*sb));
4834   brelse(bp);
4835 }
4836 
4837 
4838 static void
4839 bzero(int dev, int bno)
4840 {
4841   struct buf *bp;
4842 
4843   bp = bread(dev, bno);
4844   memset(bp->data, 0, BSIZE);
4845   log_write(bp);
4846   brelse(bp);
4847 }
4848 
4849 
4850 
4851 
4852 
4853 static uint
4854 balloc(uint dev)
4855 {
4856   int b, bi, m;
4857   struct buf *bp;
4858 
4859   bp = 0;
4860   for(b = 0; b < sb.size; b += BPB){
4861     bp = bread(dev, BBLOCK(b, sb));
4862     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
4863       m = 1 << (bi % 8);
4864       if((bp->data[bi/8] & m) == 0){  
4865         bp->data[bi/8] |= m;  
4866         log_write(bp);
4867         brelse(bp);
4868         bzero(dev, b + bi);
4869         return b + bi;
4870       }
4871     }
4872     brelse(bp);
4873   }
4874   panic("balloc: out of blocks");
4875 }
4876 
4877 
4878 static void
4879 bfree(int dev, uint b)
4880 {
4881   struct buf *bp;
4882   int bi, m;
4883 
4884   readsb(dev, &sb);
4885   bp = bread(dev, BBLOCK(b, sb));
4886   bi = b % BPB;
4887   m = 1 << (bi % 8);
4888   if((bp->data[bi/8] & m) == 0)
4889     panic("freeing free block");
4890   bp->data[bi/8] &= ~m;
4891   log_write(bp);
4892   brelse(bp);
4893 }
4894 
4895 
4896 
4897 
4898 
4899 
4900 
4901 
4902 
4903 
4904 
4905 
4906 
4907 
4908 
4909 
4910 
4911 
4912 
4913 
4914 
4915 
4916 
4917 
4918 
4919 
4920 
4921 
4922 
4923 
4924 
4925 
4926 
4927 
4928 
4929 
4930 
4931 
4932 
4933 
4934 
4935 
4936 
4937 
4938 
4939 
4940 
4941 
4942 
4943 
4944 
4945 
4946 
4947 
4948 
4949 
4950 
4951 
4952 
4953 
4954 
4955 
4956 
4957 
4958 
4959 
4960 
4961 
4962 struct {
4963   struct spinlock lock;
4964   struct inode inode[NINODE];
4965 } icache;
4966 
4967 void
4968 iinit(int dev)
4969 {
4970   initlock(&icache.lock, "icache");
4971   readsb(dev, &sb);
4972   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d inodestart %d bmap start %d\n", sb.size,
4973           sb.nblocks, sb.ninodes, sb.nlog, sb.logstart, sb.inodestart, sb.bmapstart);
4974 }
4975 
4976 static struct inode* iget(uint dev, uint inum);
4977 
4978 
4979 
4980 
4981 
4982 
4983 
4984 
4985 
4986 
4987 
4988 
4989 
4990 
4991 
4992 
4993 
4994 
4995 
4996 
4997 
4998 
4999 
5000 
5001 
5002 struct inode*
5003 ialloc(uint dev, short type)
5004 {
5005   int inum;
5006   struct buf *bp;
5007   struct dinode *dip;
5008 
5009   for(inum = 1; inum < sb.ninodes; inum++){
5010     bp = bread(dev, IBLOCK(inum, sb));
5011     dip = (struct dinode*)bp->data + inum%IPB;
5012     if(dip->type == 0){  
5013       memset(dip, 0, sizeof(*dip));
5014       dip->type = type;
5015       log_write(bp);   
5016       brelse(bp);
5017       return iget(dev, inum);
5018     }
5019     brelse(bp);
5020   }
5021   panic("ialloc: no inodes");
5022 }
5023 
5024 
5025 void
5026 iupdate(struct inode *ip)
5027 {
5028   struct buf *bp;
5029   struct dinode *dip;
5030 
5031   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5032   dip = (struct dinode*)bp->data + ip->inum%IPB;
5033   dip->type = ip->type;
5034   dip->major = ip->major;
5035   dip->minor = ip->minor;
5036   dip->nlink = ip->nlink;
5037   dip->size = ip->size;
5038   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
5039   log_write(bp);
5040   brelse(bp);
5041 }
5042 
5043 
5044 
5045 
5046 
5047 
5048 
5049 
5050 
5051 
5052 
5053 static struct inode*
5054 iget(uint dev, uint inum)
5055 {
5056   struct inode *ip, *empty;
5057 
5058   acquire(&icache.lock);
5059 
5060   
5061   empty = 0;
5062   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
5063     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
5064       ip->ref++;
5065       release(&icache.lock);
5066       return ip;
5067     }
5068     if(empty == 0 && ip->ref == 0)    
5069       empty = ip;
5070   }
5071 
5072   
5073   if(empty == 0)
5074     panic("iget: no inodes");
5075 
5076   ip = empty;
5077   ip->dev = dev;
5078   ip->inum = inum;
5079   ip->ref = 1;
5080   ip->flags = 0;
5081   release(&icache.lock);
5082 
5083   return ip;
5084 }
5085 
5086 
5087 
5088 struct inode*
5089 idup(struct inode *ip)
5090 {
5091   acquire(&icache.lock);
5092   ip->ref++;
5093   release(&icache.lock);
5094   return ip;
5095 }
5096 
5097 
5098 
5099 
5100 
5101 
5102 void
5103 ilock(struct inode *ip)
5104 {
5105   struct buf *bp;
5106   struct dinode *dip;
5107 
5108   if(ip == 0 || ip->ref < 1)
5109     panic("ilock");
5110 
5111   acquire(&icache.lock);
5112   while(ip->flags & I_BUSY)
5113     sleep(ip, &icache.lock);
5114   ip->flags |= I_BUSY;
5115   release(&icache.lock);
5116 
5117   if(!(ip->flags & I_VALID)){
5118     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5119     dip = (struct dinode*)bp->data + ip->inum%IPB;
5120     ip->type = dip->type;
5121     ip->major = dip->major;
5122     ip->minor = dip->minor;
5123     ip->nlink = dip->nlink;
5124     ip->size = dip->size;
5125     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
5126     brelse(bp);
5127     ip->flags |= I_VALID;
5128     if(ip->type == 0)
5129       panic("ilock: no type");
5130   }
5131 }
5132 
5133 
5134 void
5135 iunlock(struct inode *ip)
5136 {
5137   if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
5138     panic("iunlock");
5139 
5140   acquire(&icache.lock);
5141   ip->flags &= ~I_BUSY;
5142   wakeup(ip);
5143   release(&icache.lock);
5144 }
5145 
5146 
5147 
5148 
5149 
5150 
5151 
5152 
5153 
5154 
5155 
5156 
5157 void
5158 iput(struct inode *ip)
5159 {
5160   acquire(&icache.lock);
5161   if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
5162     
5163     if(ip->flags & I_BUSY)
5164       panic("iput busy");
5165     ip->flags |= I_BUSY;
5166     release(&icache.lock);
5167     itrunc(ip);
5168     ip->type = 0;
5169     iupdate(ip);
5170     acquire(&icache.lock);
5171     ip->flags = 0;
5172     wakeup(ip);
5173   }
5174   ip->ref--;
5175   release(&icache.lock);
5176 }
5177 
5178 
5179 void
5180 iunlockput(struct inode *ip)
5181 {
5182   iunlock(ip);
5183   iput(ip);
5184 }
5185 
5186 
5187 
5188 
5189 
5190 
5191 
5192 
5193 
5194 
5195 
5196 
5197 
5198 
5199 
5200 
5201 
5202 
5203 
5204 
5205 
5206 
5207 
5208 
5209 static uint
5210 bmap(struct inode *ip, uint bn)
5211 {
5212   uint addr, *a;
5213   struct buf *bp;
5214 
5215   if(bn < NDIRECT){
5216     if((addr = ip->addrs[bn]) == 0)
5217       ip->addrs[bn] = addr = balloc(ip->dev);
5218     return addr;
5219   }
5220   bn -= NDIRECT;
5221 
5222   if(bn < NINDIRECT){
5223     
5224     if((addr = ip->addrs[NDIRECT]) == 0)
5225       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
5226     bp = bread(ip->dev, addr);
5227     a = (uint*)bp->data;
5228     if((addr = a[bn]) == 0){
5229       a[bn] = addr = balloc(ip->dev);
5230       log_write(bp);
5231     }
5232     brelse(bp);
5233     return addr;
5234   }
5235 
5236   panic("bmap: out of range");
5237 }
5238 
5239 
5240 
5241 
5242 
5243 
5244 
5245 
5246 
5247 
5248 
5249 
5250 
5251 
5252 
5253 
5254 
5255 static void
5256 itrunc(struct inode *ip)
5257 {
5258   int i, j;
5259   struct buf *bp;
5260   uint *a;
5261 
5262   for(i = 0; i < NDIRECT; i++){
5263     if(ip->addrs[i]){
5264       bfree(ip->dev, ip->addrs[i]);
5265       ip->addrs[i] = 0;
5266     }
5267   }
5268 
5269   if(ip->addrs[NDIRECT]){
5270     bp = bread(ip->dev, ip->addrs[NDIRECT]);
5271     a = (uint*)bp->data;
5272     for(j = 0; j < NINDIRECT; j++){
5273       if(a[j])
5274         bfree(ip->dev, a[j]);
5275     }
5276     brelse(bp);
5277     bfree(ip->dev, ip->addrs[NDIRECT]);
5278     ip->addrs[NDIRECT] = 0;
5279   }
5280 
5281   ip->size = 0;
5282   iupdate(ip);
5283 }
5284 
5285 
5286 void
5287 stati(struct inode *ip, struct stat *st)
5288 {
5289   st->dev = ip->dev;
5290   st->ino = ip->inum;
5291   st->type = ip->type;
5292   st->nlink = ip->nlink;
5293   st->size = ip->size;
5294 }
5295 
5296 
5297 
5298 
5299 
5300 
5301 int
5302 readi(struct inode *ip, char *dst, uint off, uint n)
5303 {
5304   uint tot, m;
5305   struct buf *bp;
5306 
5307   if(ip->type == T_DEV){
5308     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
5309       return -1;
5310     return devsw[ip->major].read(ip, dst, n);
5311   }
5312 
5313   if(off > ip->size || off + n < off)
5314     return -1;
5315   if(off + n > ip->size)
5316     n = ip->size - off;
5317 
5318   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
5319     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5320     m = min(n - tot, BSIZE - off%BSIZE);
5321     memmove(dst, bp->data + off%BSIZE, m);
5322     brelse(bp);
5323   }
5324   return n;
5325 }
5326 
5327 
5328 
5329 
5330 
5331 
5332 
5333 
5334 
5335 
5336 
5337 
5338 
5339 
5340 
5341 
5342 
5343 
5344 
5345 
5346 
5347 
5348 
5349 
5350 
5351 int
5352 writei(struct inode *ip, char *src, uint off, uint n)
5353 {
5354   uint tot, m;
5355   struct buf *bp;
5356 
5357   if(ip->type == T_DEV){
5358     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5359       return -1;
5360     return devsw[ip->major].write(ip, src, n);
5361   }
5362 
5363   if(off > ip->size || off + n < off)
5364     return -1;
5365   if(off + n > MAXFILE*BSIZE)
5366     return -1;
5367 
5368   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5369     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5370     m = min(n - tot, BSIZE - off%BSIZE);
5371     memmove(bp->data + off%BSIZE, src, m);
5372     log_write(bp);
5373     brelse(bp);
5374   }
5375 
5376   if(n > 0 && off > ip->size){
5377     ip->size = off;
5378     iupdate(ip);
5379   }
5380   return n;
5381 }
5382 
5383 
5384 
5385 
5386 
5387 
5388 
5389 
5390 
5391 
5392 
5393 
5394 
5395 
5396 
5397 
5398 
5399 
5400 
5401 
5402 int
5403 namecmp(const char *s, const char *t)
5404 {
5405   return strncmp(s, t, DIRSIZ);
5406 }
5407 
5408 
5409 
5410 struct inode*
5411 dirlookup(struct inode *dp, char *name, uint *poff)
5412 {
5413   uint off, inum;
5414   struct dirent de;
5415 
5416   if(dp->type != T_DIR)
5417     panic("dirlookup not DIR");
5418 
5419   for(off = 0; off < dp->size; off += sizeof(de)){
5420     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5421       panic("dirlink read");
5422     if(de.inum == 0)
5423       continue;
5424     if(namecmp(name, de.name) == 0){
5425       
5426       if(poff)
5427         *poff = off;
5428       inum = de.inum;
5429       return iget(dp->dev, inum);
5430     }
5431   }
5432 
5433   return 0;
5434 }
5435 
5436 
5437 
5438 
5439 
5440 
5441 
5442 
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450 
5451 int
5452 dirlink(struct inode *dp, char *name, uint inum)
5453 {
5454   int off;
5455   struct dirent de;
5456   struct inode *ip;
5457 
5458   
5459   if((ip = dirlookup(dp, name, 0)) != 0){
5460     iput(ip);
5461     return -1;
5462   }
5463 
5464   
5465   for(off = 0; off < dp->size; off += sizeof(de)){
5466     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5467       panic("dirlink read");
5468     if(de.inum == 0)
5469       break;
5470   }
5471 
5472   strncpy(de.name, name, DIRSIZ);
5473   de.inum = inum;
5474   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5475     panic("dirlink");
5476 
5477   return 0;
5478 }
5479 
5480 
5481 
5482 
5483 
5484 
5485 
5486 
5487 
5488 
5489 
5490 
5491 
5492 
5493 
5494 
5495 
5496 
5497 
5498 
5499 
5500 
5501 
5502 
5503 
5504 
5505 
5506 
5507 
5508 
5509 
5510 
5511 
5512 
5513 
5514 static char*
5515 skipelem(char *path, char *name)
5516 {
5517   char *s;
5518   int len;
5519 
5520   while(*path == '/')
5521     path++;
5522   if(*path == 0)
5523     return 0;
5524   s = path;
5525   while(*path != '/' && *path != 0)
5526     path++;
5527   len = path - s;
5528   if(len >= DIRSIZ)
5529     memmove(name, s, DIRSIZ);
5530   else {
5531     memmove(name, s, len);
5532     name[len] = 0;
5533   }
5534   while(*path == '/')
5535     path++;
5536   return path;
5537 }
5538 
5539 
5540 
5541 
5542 
5543 
5544 
5545 
5546 
5547 
5548 
5549 
5550 
5551 
5552 
5553 
5554 static struct inode*
5555 namex(char *path, int nameiparent, char *name)
5556 {
5557   struct inode *ip, *next;
5558 
5559   if(*path == '/')
5560     ip = iget(ROOTDEV, ROOTINO);
5561   else
5562     ip = idup(proc->cwd);
5563 
5564   while((path = skipelem(path, name)) != 0){
5565     ilock(ip);
5566     if(ip->type != T_DIR){
5567       iunlockput(ip);
5568       return 0;
5569     }
5570     if(nameiparent && *path == '\0'){
5571       
5572       iunlock(ip);
5573       return ip;
5574     }
5575     if((next = dirlookup(ip, name, 0)) == 0){
5576       iunlockput(ip);
5577       return 0;
5578     }
5579     iunlockput(ip);
5580     ip = next;
5581   }
5582   if(nameiparent){
5583     iput(ip);
5584     return 0;
5585   }
5586   return ip;
5587 }
5588 
5589 struct inode*
5590 namei(char *path)
5591 {
5592   char name[DIRSIZ];
5593   return namex(path, 0, name);
5594 }
5595 
5596 
5597 
5598 
5599 
5600 struct inode*
5601 nameiparent(char *path, char *name)
5602 {
5603   return namex(path, 1, name);
5604 }
5605 
5606 
5607 
5608 
5609 
5610 
5611 
5612 
5613 
5614 
5615 
5616 
5617 
5618 
5619 
5620 
5621 
5622 
5623 
5624 
5625 
5626 
5627 
5628 
5629 
5630 
5631 
5632 
5633 
5634 
5635 
5636 
5637 
5638 
5639 
5640 
5641 
5642 
5643 
5644 
5645 
5646 
5647 
5648 
5649 
5650 
5651 
5652 
5653 
5654 #include "types.h"
5655 #include "defs.h"
5656 #include "param.h"
5657 #include "fs.h"
5658 #include "file.h"
5659 #include "spinlock.h"
5660 
5661 struct devsw devsw[NDEV];
5662 struct {
5663   struct spinlock lock;
5664   struct file file[NFILE];
5665 } ftable;
5666 
5667 void
5668 fileinit(void)
5669 {
5670   initlock(&ftable.lock, "ftable");
5671 }
5672 
5673 
5674 struct file*
5675 filealloc(void)
5676 {
5677   struct file *f;
5678 
5679   acquire(&ftable.lock);
5680   for(f = ftable.file; f < ftable.file + NFILE; f++){
5681     if(f->ref == 0){
5682       f->ref = 1;
5683       release(&ftable.lock);
5684       return f;
5685     }
5686   }
5687   release(&ftable.lock);
5688   return 0;
5689 }
5690 
5691 
5692 
5693 
5694 
5695 
5696 
5697 
5698 
5699 
5700 
5701 struct file*
5702 filedup(struct file *f)
5703 {
5704   acquire(&ftable.lock);
5705   if(f->ref < 1)
5706     panic("filedup");
5707   f->ref++;
5708   release(&ftable.lock);
5709   return f;
5710 }
5711 
5712 
5713 void
5714 fileclose(struct file *f)
5715 {
5716   struct file ff;
5717 
5718   acquire(&ftable.lock);
5719   if(f->ref < 1)
5720     panic("fileclose");
5721   if(--f->ref > 0){
5722     release(&ftable.lock);
5723     return;
5724   }
5725   ff = *f;
5726   f->ref = 0;
5727   f->type = FD_NONE;
5728   release(&ftable.lock);
5729 
5730   if(ff.type == FD_PIPE)
5731     pipeclose(ff.pipe, ff.writable);
5732   else if(ff.type == FD_INODE){
5733     begin_op();
5734     iput(ff.ip);
5735     end_op();
5736   }
5737 }
5738 
5739 
5740 
5741 
5742 
5743 
5744 
5745 
5746 
5747 
5748 
5749 
5750 
5751 int
5752 filestat(struct file *f, struct stat *st)
5753 {
5754   if(f->type == FD_INODE){
5755     ilock(f->ip);
5756     stati(f->ip, st);
5757     iunlock(f->ip);
5758     return 0;
5759   }
5760   return -1;
5761 }
5762 
5763 
5764 int
5765 fileread(struct file *f, char *addr, int n)
5766 {
5767   int r;
5768 
5769   if(f->readable == 0)
5770     return -1;
5771   if(f->type == FD_PIPE)
5772     return piperead(f->pipe, addr, n);
5773   if(f->type == FD_INODE){
5774     ilock(f->ip);
5775     if((r = readi(f->ip, addr, f->off, n)) > 0)
5776       f->off += r;
5777     iunlock(f->ip);
5778     return r;
5779   }
5780   panic("fileread");
5781 }
5782 
5783 
5784 
5785 
5786 
5787 
5788 
5789 
5790 
5791 
5792 
5793 
5794 
5795 
5796 
5797 
5798 
5799 
5800 
5801 int
5802 filewrite(struct file *f, char *addr, int n)
5803 {
5804   int r;
5805 
5806   if(f->writable == 0)
5807     return -1;
5808   if(f->type == FD_PIPE)
5809     return pipewrite(f->pipe, addr, n);
5810   if(f->type == FD_INODE){
5811     
5812     
5813     
5814     
5815     
5816     
5817     int max = ((LOGSIZE-1-1-2) / 2) * 512;
5818     int i = 0;
5819     while(i < n){
5820       int n1 = n - i;
5821       if(n1 > max)
5822         n1 = max;
5823 
5824       begin_op();
5825       ilock(f->ip);
5826       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
5827         f->off += r;
5828       iunlock(f->ip);
5829       end_op();
5830 
5831       if(r < 0)
5832         break;
5833       if(r != n1)
5834         panic("short filewrite");
5835       i += r;
5836     }
5837     return i == n ? n : -1;
5838   }
5839   panic("filewrite");
5840 }
5841 
5842 
5843 
5844 
5845 
5846 
5847 
5848 
5849 
5850 
5851 
5852 
5853 
5854 
5855 
5856 #include "types.h"
5857 #include "defs.h"
5858 #include "param.h"
5859 #include "stat.h"
5860 #include "mmu.h"
5861 #include "proc.h"
5862 #include "fs.h"
5863 #include "file.h"
5864 #include "fcntl.h"
5865 
5866 
5867 
5868 static int
5869 argfd(int n, int *pfd, struct file **pf)
5870 {
5871   int fd;
5872   struct file *f;
5873 
5874   if(argint(n, &fd) < 0)
5875     return -1;
5876   if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
5877     return -1;
5878   if(pfd)
5879     *pfd = fd;
5880   if(pf)
5881     *pf = f;
5882   return 0;
5883 }
5884 
5885 
5886 
5887 static int
5888 fdalloc(struct file *f)
5889 {
5890   int fd;
5891 
5892   for(fd = 0; fd < NOFILE; fd++){
5893     if(proc->ofile[fd] == 0){
5894       proc->ofile[fd] = f;
5895       return fd;
5896     }
5897   }
5898   return -1;
5899 }
5900 int
5901 sys_dup(void)
5902 {
5903   struct file *f;
5904   int fd;
5905 
5906   if(argfd(0, 0, &f) < 0)
5907     return -1;
5908   if((fd=fdalloc(f)) < 0)
5909     return -1;
5910   filedup(f);
5911   return fd;
5912 }
5913 
5914 int
5915 sys_read(void)
5916 {
5917   struct file *f;
5918   int n;
5919   char *p;
5920 
5921   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5922     return -1;
5923   return fileread(f, p, n);
5924 }
5925 
5926 int
5927 sys_write(void)
5928 {
5929   struct file *f;
5930   int n;
5931   char *p;
5932 
5933   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5934     return -1;
5935   return filewrite(f, p, n);
5936 }
5937 
5938 int
5939 sys_close(void)
5940 {
5941   int fd;
5942   struct file *f;
5943 
5944   if(argfd(0, &fd, &f) < 0)
5945     return -1;
5946   proc->ofile[fd] = 0;
5947   fileclose(f);
5948   return 0;
5949 }
5950 int
5951 sys_fstat(void)
5952 {
5953   struct file *f;
5954   struct stat *st;
5955 
5956   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
5957     return -1;
5958   return filestat(f, st);
5959 }
5960 
5961 
5962 int
5963 sys_link(void)
5964 {
5965   char name[DIRSIZ], *new, *old;
5966   struct inode *dp, *ip;
5967 
5968   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
5969     return -1;
5970 
5971   begin_op();
5972   if((ip = namei(old)) == 0){
5973     end_op();
5974     return -1;
5975   }
5976 
5977   ilock(ip);
5978   if(ip->type == T_DIR){
5979     iunlockput(ip);
5980     end_op();
5981     return -1;
5982   }
5983 
5984   ip->nlink++;
5985   iupdate(ip);
5986   iunlock(ip);
5987 
5988   if((dp = nameiparent(new, name)) == 0)
5989     goto bad;
5990   ilock(dp);
5991   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
5992     iunlockput(dp);
5993     goto bad;
5994   }
5995   iunlockput(dp);
5996   iput(ip);
5997 
5998   end_op();
5999 
6000   return 0;
6001 
6002 bad:
6003   ilock(ip);
6004   ip->nlink--;
6005   iupdate(ip);
6006   iunlockput(ip);
6007   end_op();
6008   return -1;
6009 }
6010 
6011 
6012 static int
6013 isdirempty(struct inode *dp)
6014 {
6015   int off;
6016   struct dirent de;
6017 
6018   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
6019     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6020       panic("isdirempty: readi");
6021     if(de.inum != 0)
6022       return 0;
6023   }
6024   return 1;
6025 }
6026 
6027 
6028 
6029 
6030 
6031 
6032 
6033 
6034 
6035 
6036 
6037 
6038 
6039 
6040 
6041 
6042 
6043 
6044 
6045 
6046 
6047 
6048 
6049 
6050 int
6051 sys_unlink(void)
6052 {
6053   struct inode *ip, *dp;
6054   struct dirent de;
6055   char name[DIRSIZ], *path;
6056   uint off;
6057 
6058   if(argstr(0, &path) < 0)
6059     return -1;
6060 
6061   begin_op();
6062   if((dp = nameiparent(path, name)) == 0){
6063     end_op();
6064     return -1;
6065   }
6066 
6067   ilock(dp);
6068 
6069   
6070   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
6071     goto bad;
6072 
6073   if((ip = dirlookup(dp, name, &off)) == 0)
6074     goto bad;
6075   ilock(ip);
6076 
6077   if(ip->nlink < 1)
6078     panic("unlink: nlink < 1");
6079   if(ip->type == T_DIR && !isdirempty(ip)){
6080     iunlockput(ip);
6081     goto bad;
6082   }
6083 
6084   memset(&de, 0, sizeof(de));
6085   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6086     panic("unlink: writei");
6087   if(ip->type == T_DIR){
6088     dp->nlink--;
6089     iupdate(dp);
6090   }
6091   iunlockput(dp);
6092 
6093   ip->nlink--;
6094   iupdate(ip);
6095   iunlockput(ip);
6096 
6097   end_op();
6098 
6099   return 0;
6100 bad:
6101   iunlockput(dp);
6102   end_op();
6103   return -1;
6104 }
6105 
6106 static struct inode*
6107 create(char *path, short type, short major, short minor)
6108 {
6109   uint off;
6110   struct inode *ip, *dp;
6111   char name[DIRSIZ];
6112 
6113   if((dp = nameiparent(path, name)) == 0)
6114     return 0;
6115   ilock(dp);
6116 
6117   if((ip = dirlookup(dp, name, &off)) != 0){
6118     iunlockput(dp);
6119     ilock(ip);
6120     if(type == T_FILE && ip->type == T_FILE)
6121       return ip;
6122     iunlockput(ip);
6123     return 0;
6124   }
6125 
6126   if((ip = ialloc(dp->dev, type)) == 0)
6127     panic("create: ialloc");
6128 
6129   ilock(ip);
6130   ip->major = major;
6131   ip->minor = minor;
6132   ip->nlink = 1;
6133   iupdate(ip);
6134 
6135   if(type == T_DIR){  
6136     dp->nlink++;  
6137     iupdate(dp);
6138     
6139     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
6140       panic("create dots");
6141   }
6142 
6143   if(dirlink(dp, name, ip->inum) < 0)
6144     panic("create: dirlink");
6145 
6146   iunlockput(dp);
6147 
6148   return ip;
6149 }
6150 int
6151 sys_open(void)
6152 {
6153   char *path;
6154   int fd, omode;
6155   struct file *f;
6156   struct inode *ip;
6157 
6158   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
6159     return -1;
6160 
6161   begin_op();
6162 
6163   if(omode & O_CREATE){
6164     ip = create(path, T_FILE, 0, 0);
6165     if(ip == 0){
6166       end_op();
6167       return -1;
6168     }
6169   } else {
6170     if((ip = namei(path)) == 0){
6171       end_op();
6172       return -1;
6173     }
6174     ilock(ip);
6175     if(ip->type == T_DIR && omode != O_RDONLY){
6176       iunlockput(ip);
6177       end_op();
6178       return -1;
6179     }
6180   }
6181 
6182   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
6183     if(f)
6184       fileclose(f);
6185     iunlockput(ip);
6186     end_op();
6187     return -1;
6188   }
6189   iunlock(ip);
6190   end_op();
6191 
6192   f->type = FD_INODE;
6193   f->ip = ip;
6194   f->off = 0;
6195   f->readable = !(omode & O_WRONLY);
6196   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
6197   return fd;
6198 }
6199 
6200 int
6201 sys_mkdir(void)
6202 {
6203   char *path;
6204   struct inode *ip;
6205 
6206   begin_op();
6207   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
6208     end_op();
6209     return -1;
6210   }
6211   iunlockput(ip);
6212   end_op();
6213   return 0;
6214 }
6215 
6216 int
6217 sys_mknod(void)
6218 {
6219   struct inode *ip;
6220   char *path;
6221   int len;
6222   int major, minor;
6223 
6224   begin_op();
6225   if((len=argstr(0, &path)) < 0 ||
6226      argint(1, &major) < 0 ||
6227      argint(2, &minor) < 0 ||
6228      (ip = create(path, T_DEV, major, minor)) == 0){
6229     end_op();
6230     return -1;
6231   }
6232   iunlockput(ip);
6233   end_op();
6234   return 0;
6235 }
6236 
6237 
6238 
6239 
6240 
6241 
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 int
6251 sys_chdir(void)
6252 {
6253   char *path;
6254   struct inode *ip;
6255 
6256   begin_op();
6257   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
6258     end_op();
6259     return -1;
6260   }
6261   ilock(ip);
6262   if(ip->type != T_DIR){
6263     iunlockput(ip);
6264     end_op();
6265     return -1;
6266   }
6267   iunlock(ip);
6268   iput(proc->cwd);
6269   end_op();
6270   proc->cwd = ip;
6271   return 0;
6272 }
6273 
6274 int
6275 sys_exec(void)
6276 {
6277   char *path, *argv[MAXARG];
6278   int i;
6279   uint uargv, uarg;
6280 
6281   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
6282     return -1;
6283   }
6284   memset(argv, 0, sizeof(argv));
6285   for(i=0;; i++){
6286     if(i >= NELEM(argv))
6287       return -1;
6288     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
6289       return -1;
6290     if(uarg == 0){
6291       argv[i] = 0;
6292       break;
6293     }
6294     if(fetchstr(uarg, &argv[i]) < 0)
6295       return -1;
6296   }
6297   return exec(path, argv);
6298 }
6299 
6300 int
6301 sys_pipe(void)
6302 {
6303   int *fd;
6304   struct file *rf, *wf;
6305   int fd0, fd1;
6306 
6307   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
6308     return -1;
6309   if(pipealloc(&rf, &wf) < 0)
6310     return -1;
6311   fd0 = -1;
6312   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
6313     if(fd0 >= 0)
6314       proc->ofile[fd0] = 0;
6315     fileclose(rf);
6316     fileclose(wf);
6317     return -1;
6318   }
6319   fd[0] = fd0;
6320   fd[1] = fd1;
6321   return 0;
6322 }
6323 
6324 
6325 
6326 
6327 
6328 
6329 
6330 
6331 
6332 
6333 
6334 
6335 
6336 
6337 
6338 
6339 
6340 
6341 
6342 
6343 
6344 
6345 
6346 
6347 
6348 
6349 
6350 #include "types.h"
6351 #include "param.h"
6352 #include "memlayout.h"
6353 #include "mmu.h"
6354 #include "proc.h"
6355 #include "defs.h"
6356 #include "x86.h"
6357 #include "elf.h"
6358 
6359 int
6360 exec(char *path, char **argv)
6361 {
6362   char *s, *last;
6363   int i, off;
6364   uint argc, sz, sp, ustack[3+MAXARG+1];
6365   struct elfhdr elf;
6366   struct inode *ip;
6367   struct proghdr ph;
6368   pde_t *pgdir, *oldpgdir;
6369 
6370   begin_op();
6371   if((ip = namei(path)) == 0){
6372     end_op();
6373     return -1;
6374   }
6375   ilock(ip);
6376   pgdir = 0;
6377 
6378   
6379   if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
6380     goto bad;
6381   if(elf.magic != ELF_MAGIC)
6382     goto bad;
6383 
6384   if((pgdir = setupkvm()) == 0)
6385     goto bad;
6386 
6387   
6388   sz = 0;
6389   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
6390     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
6391       goto bad;
6392     if(ph.type != ELF_PROG_LOAD)
6393       continue;
6394     if(ph.memsz < ph.filesz)
6395       goto bad;
6396     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
6397       goto bad;
6398     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
6399       goto bad;
6400   }
6401   iunlockput(ip);
6402   end_op();
6403   ip = 0;
6404 
6405   
6406   
6407   sz = PGROUNDUP(sz);
6408   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
6409     goto bad;
6410   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
6411   sp = sz;
6412 
6413   
6414   for(argc = 0; argv[argc]; argc++) {
6415     if(argc >= MAXARG)
6416       goto bad;
6417     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
6418     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
6419       goto bad;
6420     ustack[3+argc] = sp;
6421   }
6422   ustack[3+argc] = 0;
6423 
6424   ustack[0] = 0xffffffff;  
6425   ustack[1] = argc;
6426   ustack[2] = sp - (argc+1)*4;  
6427 
6428   sp -= (3+argc+1) * 4;
6429   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
6430     goto bad;
6431 
6432   
6433   for(last=s=path; *s; s++)
6434     if(*s == '/')
6435       last = s+1;
6436   safestrcpy(proc->name, last, sizeof(proc->name));
6437 
6438   
6439   oldpgdir = proc->pgdir;
6440   proc->pgdir = pgdir;
6441   proc->sz = sz;
6442   proc->tf->eip = elf.entry;  
6443   proc->tf->esp = sp;
6444   switchuvm(proc);
6445   freevm(oldpgdir);
6446   return 0;
6447 
6448 
6449 
6450  bad:
6451   if(pgdir)
6452     freevm(pgdir);
6453   if(ip){
6454     iunlockput(ip);
6455     end_op();
6456   }
6457   return -1;
6458 }
6459 
6460 
6461 
6462 
6463 
6464 
6465 
6466 
6467 
6468 
6469 
6470 
6471 
6472 
6473 
6474 
6475 
6476 
6477 
6478 
6479 
6480 
6481 
6482 
6483 
6484 
6485 
6486 
6487 
6488 
6489 
6490 
6491 
6492 
6493 
6494 
6495 
6496 
6497 
6498 
6499 
6500 #include "types.h"
6501 #include "defs.h"
6502 #include "param.h"
6503 #include "mmu.h"
6504 #include "proc.h"
6505 #include "fs.h"
6506 #include "file.h"
6507 #include "spinlock.h"
6508 
6509 #define PIPESIZE 512
6510 
6511 struct pipe {
6512   struct spinlock lock;
6513   char data[PIPESIZE];
6514   uint nread;     
6515   uint nwrite;    
6516   int readopen;   
6517   int writeopen;  
6518 };
6519 
6520 int
6521 pipealloc(struct file **f0, struct file **f1)
6522 {
6523   struct pipe *p;
6524 
6525   p = 0;
6526   *f0 = *f1 = 0;
6527   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
6528     goto bad;
6529   if((p = (struct pipe*)kalloc()) == 0)
6530     goto bad;
6531   p->readopen = 1;
6532   p->writeopen = 1;
6533   p->nwrite = 0;
6534   p->nread = 0;
6535   initlock(&p->lock, "pipe");
6536   (*f0)->type = FD_PIPE;
6537   (*f0)->readable = 1;
6538   (*f0)->writable = 0;
6539   (*f0)->pipe = p;
6540   (*f1)->type = FD_PIPE;
6541   (*f1)->readable = 0;
6542   (*f1)->writable = 1;
6543   (*f1)->pipe = p;
6544   return 0;
6545 
6546 
6547 
6548 
6549 
6550  bad:
6551   if(p)
6552     kfree((char*)p);
6553   if(*f0)
6554     fileclose(*f0);
6555   if(*f1)
6556     fileclose(*f1);
6557   return -1;
6558 }
6559 
6560 void
6561 pipeclose(struct pipe *p, int writable)
6562 {
6563   acquire(&p->lock);
6564   if(writable){
6565     p->writeopen = 0;
6566     wakeup(&p->nread);
6567   } else {
6568     p->readopen = 0;
6569     wakeup(&p->nwrite);
6570   }
6571   if(p->readopen == 0 && p->writeopen == 0){
6572     release(&p->lock);
6573     kfree((char*)p);
6574   } else
6575     release(&p->lock);
6576 }
6577 
6578 
6579 int
6580 pipewrite(struct pipe *p, char *addr, int n)
6581 {
6582   int i;
6583 
6584   acquire(&p->lock);
6585   for(i = 0; i < n; i++){
6586     while(p->nwrite == p->nread + PIPESIZE){  
6587       if(p->readopen == 0 || proc->killed){
6588         release(&p->lock);
6589         return -1;
6590       }
6591       wakeup(&p->nread);
6592       sleep(&p->nwrite, &p->lock);  
6593     }
6594     p->data[p->nwrite++ % PIPESIZE] = addr[i];
6595   }
6596   wakeup(&p->nread);  
6597   release(&p->lock);
6598   return n;
6599 }
6600 int
6601 piperead(struct pipe *p, char *addr, int n)
6602 {
6603   int i;
6604 
6605   acquire(&p->lock);
6606   while(p->nread == p->nwrite && p->writeopen){  
6607     if(proc->killed){
6608       release(&p->lock);
6609       return -1;
6610     }
6611     sleep(&p->nread, &p->lock); 
6612   }
6613   for(i = 0; i < n; i++){  
6614     if(p->nread == p->nwrite)
6615       break;
6616     addr[i] = p->data[p->nread++ % PIPESIZE];
6617   }
6618   wakeup(&p->nwrite);  
6619   release(&p->lock);
6620   return i;
6621 }
6622 
6623 
6624 
6625 
6626 
6627 
6628 
6629 
6630 
6631 
6632 
6633 
6634 
6635 
6636 
6637 
6638 
6639 
6640 
6641 
6642 
6643 
6644 
6645 
6646 
6647 
6648 
6649 
6650 #include "types.h"
6651 #include "x86.h"
6652 
6653 void*
6654 memset(void *dst, int c, uint n)
6655 {
6656   if ((int)dst%4 == 0 && n%4 == 0){
6657     c &= 0xFF;
6658     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
6659   } else
6660     stosb(dst, c, n);
6661   return dst;
6662 }
6663 
6664 int
6665 memcmp(const void *v1, const void *v2, uint n)
6666 {
6667   const uchar *s1, *s2;
6668 
6669   s1 = v1;
6670   s2 = v2;
6671   while(n-- > 0){
6672     if(*s1 != *s2)
6673       return *s1 - *s2;
6674     s1++, s2++;
6675   }
6676 
6677   return 0;
6678 }
6679 
6680 void*
6681 memmove(void *dst, const void *src, uint n)
6682 {
6683   const char *s;
6684   char *d;
6685 
6686   s = src;
6687   d = dst;
6688   if(s < d && s + n > d){
6689     s += n;
6690     d += n;
6691     while(n-- > 0)
6692       *--d = *--s;
6693   } else
6694     while(n-- > 0)
6695       *d++ = *s++;
6696 
6697   return dst;
6698 }
6699 
6700 
6701 void*
6702 memcpy(void *dst, const void *src, uint n)
6703 {
6704   return memmove(dst, src, n);
6705 }
6706 
6707 int
6708 strncmp(const char *p, const char *q, uint n)
6709 {
6710   while(n > 0 && *p && *p == *q)
6711     n--, p++, q++;
6712   if(n == 0)
6713     return 0;
6714   return (uchar)*p - (uchar)*q;
6715 }
6716 
6717 char*
6718 strncpy(char *s, const char *t, int n)
6719 {
6720   char *os;
6721 
6722   os = s;
6723   while(n-- > 0 && (*s++ = *t++) != 0)
6724     ;
6725   while(n-- > 0)
6726     *s++ = 0;
6727   return os;
6728 }
6729 
6730 
6731 char*
6732 safestrcpy(char *s, const char *t, int n)
6733 {
6734   char *os;
6735 
6736   os = s;
6737   if(n <= 0)
6738     return os;
6739   while(--n > 0 && (*s++ = *t++) != 0)
6740     ;
6741   *s = 0;
6742   return os;
6743 }
6744 
6745 
6746 
6747 
6748 
6749 
6750 int
6751 strlen(const char *s)
6752 {
6753   int n;
6754 
6755   for(n = 0; s[n]; n++)
6756     ;
6757   return n;
6758 }
6759 
6760 
6761 
6762 
6763 
6764 
6765 
6766 
6767 
6768 
6769 
6770 
6771 
6772 
6773 
6774 
6775 
6776 
6777 
6778 
6779 
6780 
6781 
6782 
6783 
6784 
6785 
6786 
6787 
6788 
6789 
6790 
6791 
6792 
6793 
6794 
6795 
6796 
6797 
6798 
6799 
6800 
6801 
6802 struct mp {             
6803   uchar signature[4];           
6804   void *physaddr;               
6805   uchar length;                 
6806   uchar specrev;                
6807   uchar checksum;               
6808   uchar type;                   
6809   uchar imcrp;
6810   uchar reserved[3];
6811 };
6812 
6813 struct mpconf {         
6814   uchar signature[4];           
6815   ushort length;                
6816   uchar version;                
6817   uchar checksum;               
6818   uchar product[20];            
6819   uint *oemtable;               
6820   ushort oemlength;             
6821   ushort entry;                 
6822   uint *lapicaddr;              
6823   ushort xlength;               
6824   uchar xchecksum;              
6825   uchar reserved;
6826 };
6827 
6828 struct mpproc {         
6829   uchar type;                   
6830   uchar apicid;                 
6831   uchar version;                
6832   uchar flags;                  
6833     #define MPBOOT 0x02           
6834   uchar signature[4];           
6835   uint feature;                 
6836   uchar reserved[8];
6837 };
6838 
6839 struct mpioapic {       
6840   uchar type;                   
6841   uchar apicno;                 
6842   uchar version;                
6843   uchar flags;                  
6844   uint *addr;                  
6845 };
6846 
6847 
6848 
6849 
6850 
6851 #define MPPROC    0x00  
6852 #define MPBUS     0x01  
6853 #define MPIOAPIC  0x02  
6854 #define MPIOINTR  0x03  
6855 #define MPLINTR   0x04  
6856 
6857 
6858 
6859 
6860 
6861 
6862 
6863 
6864 
6865 
6866 
6867 
6868 
6869 
6870 
6871 
6872 
6873 
6874 
6875 
6876 
6877 
6878 
6879 
6880 
6881 
6882 
6883 
6884 
6885 
6886 
6887 
6888 
6889 
6890 
6891 
6892 
6893 
6894 
6895 
6896 
6897 
6898 
6899 
6900 
6901 
6902 
6903 
6904 
6905 
6906 
6907 
6908 
6909 
6910 
6911 
6912 
6913 
6914 
6915 
6916 
6917 
6918 
6919 
6920 
6921 
6922 
6923 
6924 
6925 
6926 
6927 
6928 
6929 
6930 
6931 
6932 
6933 
6934 
6935 
6936 
6937 
6938 
6939 
6940 
6941 
6942 
6943 
6944 
6945 
6946 
6947 
6948 
6949 
6950 
6951 
6952 
6953 
6954 #include "types.h"
6955 #include "defs.h"
6956 #include "param.h"
6957 #include "memlayout.h"
6958 #include "mp.h"
6959 #include "x86.h"
6960 #include "mmu.h"
6961 #include "proc.h"
6962 
6963 struct cpu cpus[NCPU];
6964 static struct cpu *bcpu;
6965 int ismp;
6966 int ncpu;
6967 uchar ioapicid;
6968 
6969 int
6970 mpbcpu(void)
6971 {
6972   return bcpu-cpus;
6973 }
6974 
6975 static uchar
6976 sum(uchar *addr, int len)
6977 {
6978   int i, sum;
6979 
6980   sum = 0;
6981   for(i=0; i<len; i++)
6982     sum += addr[i];
6983   return sum;
6984 }
6985 
6986 
6987 static struct mp*
6988 mpsearch1(uint a, int len)
6989 {
6990   uchar *e, *p, *addr;
6991 
6992   addr = p2v(a);
6993   e = addr+len;
6994   for(p = addr; p < e; p += sizeof(struct mp))
6995     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
6996       return (struct mp*)p;
6997   return 0;
6998 }
6999 
7000 
7001 
7002 
7003 
7004 
7005 static struct mp*
7006 mpsearch(void)
7007 {
7008   uchar *bda;
7009   uint p;
7010   struct mp *mp;
7011 
7012   bda = (uchar *) P2V(0x400);
7013   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
7014     if((mp = mpsearch1(p, 1024)))
7015       return mp;
7016   } else {
7017     p = ((bda[0x14]<<8)|bda[0x13])*1024;
7018     if((mp = mpsearch1(p-1024, 1024)))
7019       return mp;
7020   }
7021   return mpsearch1(0xF0000, 0x10000);
7022 }
7023 
7024 
7025 
7026 
7027 
7028 
7029 static struct mpconf*
7030 mpconfig(struct mp **pmp)
7031 {
7032   struct mpconf *conf;
7033   struct mp *mp;
7034 
7035   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
7036     return 0;
7037   conf = (struct mpconf*) p2v((uint) mp->physaddr);
7038   if(memcmp(conf, "PCMP", 4) != 0)
7039     return 0;
7040   if(conf->version != 1 && conf->version != 4)
7041     return 0;
7042   if(sum((uchar*)conf, conf->length) != 0)
7043     return 0;
7044   *pmp = mp;
7045   return conf;
7046 }
7047 
7048 
7049 
7050 void
7051 mpinit(void)
7052 {
7053   uchar *p, *e;
7054   struct mp *mp;
7055   struct mpconf *conf;
7056   struct mpproc *proc;
7057   struct mpioapic *ioapic;
7058 
7059   bcpu = &cpus[0];
7060   if((conf = mpconfig(&mp)) == 0)
7061     return;
7062   ismp = 1;
7063   lapic = (uint*)conf->lapicaddr;
7064   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
7065     switch(*p){
7066     case MPPROC:
7067       proc = (struct mpproc*)p;
7068       if(ncpu != proc->apicid){
7069         cprintf("mpinit: ncpu=%d apicid=%d\n", ncpu, proc->apicid);
7070         ismp = 0;
7071       }
7072       if(proc->flags & MPBOOT)
7073         bcpu = &cpus[ncpu];
7074       cpus[ncpu].id = ncpu;
7075       ncpu++;
7076       p += sizeof(struct mpproc);
7077       continue;
7078     case MPIOAPIC:
7079       ioapic = (struct mpioapic*)p;
7080       ioapicid = ioapic->apicno;
7081       p += sizeof(struct mpioapic);
7082       continue;
7083     case MPBUS:
7084     case MPIOINTR:
7085     case MPLINTR:
7086       p += 8;
7087       continue;
7088     default:
7089       cprintf("mpinit: unknown config type %x\n", *p);
7090       ismp = 0;
7091     }
7092   }
7093   if(!ismp){
7094     
7095     ncpu = 1;
7096     lapic = 0;
7097     ioapicid = 0;
7098     return;
7099   }
7100   if(mp->imcrp){
7101     
7102     
7103     outb(0x22, 0x70);   
7104     outb(0x23, inb(0x23) | 1);  
7105   }
7106 }
7107 
7108 
7109 
7110 
7111 
7112 
7113 
7114 
7115 
7116 
7117 
7118 
7119 
7120 
7121 
7122 
7123 
7124 
7125 
7126 
7127 
7128 
7129 
7130 
7131 
7132 
7133 
7134 
7135 
7136 
7137 
7138 
7139 
7140 
7141 
7142 
7143 
7144 
7145 
7146 
7147 
7148 
7149 
7150 
7151 
7152 
7153 #include "types.h"
7154 #include "defs.h"
7155 #include "date.h"
7156 #include "memlayout.h"
7157 #include "traps.h"
7158 #include "mmu.h"
7159 #include "x86.h"
7160 
7161 
7162 #define ID      (0x0020/4)   
7163 #define VER     (0x0030/4)   
7164 #define TPR     (0x0080/4)   
7165 #define EOI     (0x00B0/4)   
7166 #define SVR     (0x00F0/4)   
7167   #define ENABLE     0x00000100   
7168 #define ESR     (0x0280/4)   
7169 #define ICRLO   (0x0300/4)   
7170   #define INIT       0x00000500   
7171   #define STARTUP    0x00000600   
7172   #define DELIVS     0x00001000   
7173   #define ASSERT     0x00004000   
7174   #define DEASSERT   0x00000000
7175   #define LEVEL      0x00008000   
7176   #define BCAST      0x00080000   
7177   #define BUSY       0x00001000
7178   #define FIXED      0x00000000
7179 #define ICRHI   (0x0310/4)   
7180 #define TIMER   (0x0320/4)   
7181   #define X1         0x0000000B   
7182   #define PERIODIC   0x00020000   
7183 #define PCINT   (0x0340/4)   
7184 #define LINT0   (0x0350/4)   
7185 #define LINT1   (0x0360/4)   
7186 #define ERROR   (0x0370/4)   
7187   #define MASKED     0x00010000   
7188 #define TICR    (0x0380/4)   
7189 #define TCCR    (0x0390/4)   
7190 #define TDCR    (0x03E0/4)   
7191 
7192 volatile uint *lapic;  
7193 
7194 static void
7195 lapicw(int index, int value)
7196 {
7197   lapic[index] = value;
7198   lapic[ID];  
7199 }
7200 
7201 
7202 
7203 
7204 
7205 
7206 
7207 
7208 
7209 
7210 
7211 
7212 
7213 
7214 
7215 
7216 
7217 
7218 
7219 
7220 
7221 
7222 
7223 
7224 
7225 
7226 
7227 
7228 
7229 
7230 
7231 
7232 
7233 
7234 
7235 
7236 
7237 
7238 
7239 
7240 
7241 
7242 
7243 
7244 
7245 
7246 
7247 
7248 
7249 
7250 void
7251 lapicinit(void)
7252 {
7253   if(!lapic)
7254     return;
7255 
7256   
7257   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
7258 
7259   
7260   
7261   
7262   
7263   lapicw(TDCR, X1);
7264   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
7265   lapicw(TICR, 10000000);
7266 
7267   
7268   lapicw(LINT0, MASKED);
7269   lapicw(LINT1, MASKED);
7270 
7271   
7272   
7273   if(((lapic[VER]>>16) & 0xFF) >= 4)
7274     lapicw(PCINT, MASKED);
7275 
7276   
7277   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
7278 
7279   
7280   lapicw(ESR, 0);
7281   lapicw(ESR, 0);
7282 
7283   
7284   lapicw(EOI, 0);
7285 
7286   
7287   lapicw(ICRHI, 0);
7288   lapicw(ICRLO, BCAST | INIT | LEVEL);
7289   while(lapic[ICRLO] & DELIVS)
7290     ;
7291 
7292   
7293   lapicw(TPR, 0);
7294 }
7295 
7296 
7297 
7298 
7299 
7300 int
7301 cpunum(void)
7302 {
7303   
7304   
7305   
7306   
7307   
7308   if(readeflags()&FL_IF){
7309     static int n;
7310     if(n++ == 0)
7311       cprintf("cpu called from %x with interrupts enabled\n",
7312         __builtin_return_address(0));
7313   }
7314 
7315   if(lapic)
7316     return lapic[ID]>>24;
7317   return 0;
7318 }
7319 
7320 
7321 void
7322 lapiceoi(void)
7323 {
7324   if(lapic)
7325     lapicw(EOI, 0);
7326 }
7327 
7328 
7329 
7330 void
7331 microdelay(int us)
7332 {
7333 }
7334 
7335 #define CMOS_PORT    0x70
7336 #define CMOS_RETURN  0x71
7337 
7338 
7339 
7340 void
7341 lapicstartap(uchar apicid, uint addr)
7342 {
7343   int i;
7344   ushort *wrv;
7345 
7346   
7347   
7348   
7349   outb(CMOS_PORT, 0xF);  
7350   outb(CMOS_PORT+1, 0x0A);
7351   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
7352   wrv[0] = 0;
7353   wrv[1] = addr >> 4;
7354 
7355   
7356   
7357   lapicw(ICRHI, apicid<<24);
7358   lapicw(ICRLO, INIT | LEVEL | ASSERT);
7359   microdelay(200);
7360   lapicw(ICRLO, INIT | LEVEL);
7361   microdelay(100);    
7362 
7363   
7364   
7365   
7366   
7367   
7368   for(i = 0; i < 2; i++){
7369     lapicw(ICRHI, apicid<<24);
7370     lapicw(ICRLO, STARTUP | (addr>>12));
7371     microdelay(200);
7372   }
7373 }
7374 
7375 #define CMOS_STATA   0x0a
7376 #define CMOS_STATB   0x0b
7377 #define CMOS_UIP    (1 << 7)        
7378 
7379 #define SECS    0x00
7380 #define MINS    0x02
7381 #define HOURS   0x04
7382 #define DAY     0x07
7383 #define MONTH   0x08
7384 #define YEAR    0x09
7385 
7386 static uint cmos_read(uint reg)
7387 {
7388   outb(CMOS_PORT,  reg);
7389   microdelay(200);
7390 
7391   return inb(CMOS_RETURN);
7392 }
7393 
7394 
7395 
7396 
7397 
7398 
7399 
7400 static void fill_rtcdate(struct rtcdate *r)
7401 {
7402   r->second = cmos_read(SECS);
7403   r->minute = cmos_read(MINS);
7404   r->hour   = cmos_read(HOURS);
7405   r->day    = cmos_read(DAY);
7406   r->month  = cmos_read(MONTH);
7407   r->year   = cmos_read(YEAR);
7408 }
7409 
7410 
7411 void cmostime(struct rtcdate *r)
7412 {
7413   struct rtcdate t1, t2;
7414   int sb, bcd;
7415 
7416   sb = cmos_read(CMOS_STATB);
7417 
7418   bcd = (sb & (1 << 2)) == 0;
7419 
7420   
7421   for (;;) {
7422     fill_rtcdate(&t1);
7423     if (cmos_read(CMOS_STATA) & CMOS_UIP)
7424         continue;
7425     fill_rtcdate(&t2);
7426     if (memcmp(&t1, &t2, sizeof(t1)) == 0)
7427       break;
7428   }
7429 
7430   
7431   if (bcd) {
7432 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
7433     CONV(second);
7434     CONV(minute);
7435     CONV(hour  );
7436     CONV(day   );
7437     CONV(month );
7438     CONV(year  );
7439 #undef     CONV
7440   }
7441 
7442   *r = t1;
7443   r->year += 2000;
7444 }
7445 
7446 
7447 
7448 
7449 
7450 
7451 
7452 
7453 
7454 #include "types.h"
7455 #include "defs.h"
7456 #include "traps.h"
7457 
7458 #define IOAPIC  0xFEC00000   
7459 
7460 #define REG_ID     0x00  
7461 #define REG_VER    0x01  
7462 #define REG_TABLE  0x10  
7463 
7464 
7465 
7466 
7467 
7468 
7469 #define INT_DISABLED   0x00010000  
7470 #define INT_LEVEL      0x00008000  
7471 #define INT_ACTIVELOW  0x00002000  
7472 #define INT_LOGICAL    0x00000800  
7473 
7474 volatile struct ioapic *ioapic;
7475 
7476 
7477 struct ioapic {
7478   uint reg;
7479   uint pad[3];
7480   uint data;
7481 };
7482 
7483 static uint
7484 ioapicread(int reg)
7485 {
7486   ioapic->reg = reg;
7487   return ioapic->data;
7488 }
7489 
7490 static void
7491 ioapicwrite(int reg, uint data)
7492 {
7493   ioapic->reg = reg;
7494   ioapic->data = data;
7495 }
7496 
7497 
7498 
7499 
7500 void
7501 ioapicinit(void)
7502 {
7503   int i, id, maxintr;
7504 
7505   if(!ismp)
7506     return;
7507 
7508   ioapic = (volatile struct ioapic*)IOAPIC;
7509   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
7510   id = ioapicread(REG_ID) >> 24;
7511   if(id != ioapicid)
7512     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
7513 
7514   
7515   
7516   for(i = 0; i <= maxintr; i++){
7517     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
7518     ioapicwrite(REG_TABLE+2*i+1, 0);
7519   }
7520 }
7521 
7522 void
7523 ioapicenable(int irq, int cpunum)
7524 {
7525   if(!ismp)
7526     return;
7527 
7528   
7529   
7530   
7531   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
7532   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
7533 }
7534 
7535 
7536 
7537 
7538 
7539 
7540 
7541 
7542 
7543 
7544 
7545 
7546 
7547 
7548 
7549 
7550 
7551 
7552 #include "types.h"
7553 #include "x86.h"
7554 #include "traps.h"
7555 
7556 
7557 #define IO_PIC1         0x20    
7558 #define IO_PIC2         0xA0    
7559 
7560 #define IRQ_SLAVE       2       
7561 
7562 
7563 
7564 static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);
7565 
7566 static void
7567 picsetmask(ushort mask)
7568 {
7569   irqmask = mask;
7570   outb(IO_PIC1+1, mask);
7571   outb(IO_PIC2+1, mask >> 8);
7572 }
7573 
7574 void
7575 picenable(int irq)
7576 {
7577   picsetmask(irqmask & ~(1<<irq));
7578 }
7579 
7580 
7581 void
7582 picinit(void)
7583 {
7584   
7585   outb(IO_PIC1+1, 0xFF);
7586   outb(IO_PIC2+1, 0xFF);
7587 
7588   
7589 
7590   
7591   
7592   
7593   
7594   outb(IO_PIC1, 0x11);
7595 
7596   
7597   outb(IO_PIC1+1, T_IRQ0);
7598 
7599 
7600   
7601   
7602   outb(IO_PIC1+1, 1<<IRQ_SLAVE);
7603 
7604   
7605   
7606   
7607   
7608   
7609   
7610   
7611   
7612   outb(IO_PIC1+1, 0x3);
7613 
7614   
7615   outb(IO_PIC2, 0x11);                  
7616   outb(IO_PIC2+1, T_IRQ0 + 8);      
7617   outb(IO_PIC2+1, IRQ_SLAVE);           
7618   
7619   
7620   outb(IO_PIC2+1, 0x3);                 
7621 
7622   
7623   
7624   
7625   
7626   outb(IO_PIC1, 0x68);             
7627   outb(IO_PIC1, 0x0a);             
7628 
7629   outb(IO_PIC2, 0x68);             
7630   outb(IO_PIC2, 0x0a);             
7631 
7632   if(irqmask != 0xFFFF)
7633     picsetmask(irqmask);
7634 }
7635 
7636 
7637 
7638 
7639 
7640 
7641 
7642 
7643 
7644 
7645 
7646 
7647 
7648 
7649 
7650 
7651 
7652 #define KBSTATP         0x64    
7653 #define KBS_DIB         0x01    
7654 #define KBDATAP         0x60    
7655 
7656 #define NO              0
7657 
7658 #define SHIFT           (1<<0)
7659 #define CTL             (1<<1)
7660 #define ALT             (1<<2)
7661 
7662 #define CAPSLOCK        (1<<3)
7663 #define NUMLOCK         (1<<4)
7664 #define SCROLLLOCK      (1<<5)
7665 
7666 #define E0ESC           (1<<6)
7667 
7668 
7669 #define KEY_HOME        0xE0
7670 #define KEY_END         0xE1
7671 #define KEY_UP          0xE2
7672 #define KEY_DN          0xE3
7673 #define KEY_LF          0xE4
7674 #define KEY_RT          0xE5
7675 #define KEY_PGUP        0xE6
7676 #define KEY_PGDN        0xE7
7677 #define KEY_INS         0xE8
7678 #define KEY_DEL         0xE9
7679 
7680 
7681 #define C(x) (x - '@')
7682 
7683 static uchar shiftcode[256] =
7684 {
7685   [0x1D] CTL,
7686   [0x2A] SHIFT,
7687   [0x36] SHIFT,
7688   [0x38] ALT,
7689   [0x9D] CTL,
7690   [0xB8] ALT
7691 };
7692 
7693 static uchar togglecode[256] =
7694 {
7695   [0x3A] CAPSLOCK,
7696   [0x45] NUMLOCK,
7697   [0x46] SCROLLLOCK
7698 };
7699 
7700 static uchar normalmap[256] =
7701 {
7702   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
7703   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
7704   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
7705   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
7706   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
7707   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
7708   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
7709   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7710   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7711   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7712   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7713   [0x9C] '\n',      
7714   [0xB5] '/',       
7715   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7716   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7717   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7718   [0x97] KEY_HOME,  [0xCF] KEY_END,
7719   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7720 };
7721 
7722 static uchar shiftmap[256] =
7723 {
7724   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
7725   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
7726   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
7727   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
7728   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
7729   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
7730   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
7731   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7732   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7733   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7734   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7735   [0x9C] '\n',      
7736   [0xB5] '/',       
7737   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7738   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7739   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7740   [0x97] KEY_HOME,  [0xCF] KEY_END,
7741   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7742 };
7743 
7744 
7745 
7746 
7747 
7748 
7749 
7750 static uchar ctlmap[256] =
7751 {
7752   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7753   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7754   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
7755   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
7756   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
7757   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
7758   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
7759   [0x9C] '\r',      
7760   [0xB5] C('/'),    
7761   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7762   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7763   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7764   [0x97] KEY_HOME,  [0xCF] KEY_END,
7765   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7766 };
7767 
7768 
7769 
7770 
7771 
7772 
7773 
7774 
7775 
7776 
7777 
7778 
7779 
7780 
7781 
7782 
7783 
7784 
7785 
7786 
7787 
7788 
7789 
7790 
7791 
7792 
7793 
7794 
7795 
7796 
7797 
7798 
7799 
7800 #include "types.h"
7801 #include "x86.h"
7802 #include "defs.h"
7803 #include "kbd.h"
7804 
7805 int
7806 kbdgetc(void)
7807 {
7808   static uint shift;
7809   static uchar *charcode[4] = {
7810     normalmap, shiftmap, ctlmap, ctlmap
7811   };
7812   uint st, data, c;
7813 
7814   st = inb(KBSTATP);
7815   if((st & KBS_DIB) == 0)
7816     return -1;
7817   data = inb(KBDATAP);
7818 
7819   if(data == 0xE0){
7820     shift |= E0ESC;
7821     return 0;
7822   } else if(data & 0x80){
7823     
7824     data = (shift & E0ESC ? data : data & 0x7F);
7825     shift &= ~(shiftcode[data] | E0ESC);
7826     return 0;
7827   } else if(shift & E0ESC){
7828     
7829     data |= 0x80;
7830     shift &= ~E0ESC;
7831   }
7832 
7833   shift |= shiftcode[data];
7834   shift ^= togglecode[data];
7835   c = charcode[shift & (CTL | SHIFT)][data];
7836   if(shift & CAPSLOCK){
7837     if('a' <= c && c <= 'z')
7838       c += 'A' - 'a';
7839     else if('A' <= c && c <= 'Z')
7840       c += 'a' - 'A';
7841   }
7842   return c;
7843 }
7844 
7845 void
7846 kbdintr(void)
7847 {
7848   consoleintr(kbdgetc);
7849 }
7850 
7851 
7852 
7853 
7854 #include "types.h"
7855 #include "defs.h"
7856 #include "param.h"
7857 #include "traps.h"
7858 #include "spinlock.h"
7859 #include "fs.h"
7860 #include "file.h"
7861 #include "memlayout.h"
7862 #include "mmu.h"
7863 #include "proc.h"
7864 #include "x86.h"
7865 
7866 static void consputc(int);
7867 
7868 static int panicked = 0;
7869 
7870 static struct {
7871   struct spinlock lock;
7872   int locking;
7873 } cons;
7874 
7875 static void
7876 printint(int xx, int base, int sign)
7877 {
7878   static char digits[] = "0123456789abcdef";
7879   char buf[16];
7880   int i;
7881   uint x;
7882 
7883   if(sign && (sign = xx < 0))
7884     x = -xx;
7885   else
7886     x = xx;
7887 
7888   i = 0;
7889   do{
7890     buf[i++] = digits[x % base];
7891   }while((x /= base) != 0);
7892 
7893   if(sign)
7894     buf[i++] = '-';
7895 
7896   while(--i >= 0)
7897     consputc(buf[i]);
7898 }
7899 
7900 
7901 void
7902 cprintf(char *fmt, ...)
7903 {
7904   int i, c, locking;
7905   uint *argp;
7906   char *s;
7907 
7908   locking = cons.locking;
7909   if(locking)
7910     acquire(&cons.lock);
7911 
7912   if (fmt == 0)
7913     panic("null fmt");
7914 
7915   argp = (uint*)(void*)(&fmt + 1);
7916   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
7917     if(c != '%'){
7918       consputc(c);
7919       continue;
7920     }
7921     c = fmt[++i] & 0xff;
7922     if(c == 0)
7923       break;
7924     switch(c){
7925     case 'd':
7926       printint(*argp++, 10, 1);
7927       break;
7928     case 'x':
7929     case 'p':
7930       printint(*argp++, 16, 0);
7931       break;
7932     case 's':
7933       if((s = (char*)*argp++) == 0)
7934         s = "(null)";
7935       for(; *s; s++)
7936         consputc(*s);
7937       break;
7938     case '%':
7939       consputc('%');
7940       break;
7941     default:
7942       
7943       consputc('%');
7944       consputc(c);
7945       break;
7946     }
7947   }
7948 
7949 
7950   if(locking)
7951     release(&cons.lock);
7952 }
7953 
7954 void
7955 panic(char *s)
7956 {
7957   int i;
7958   uint pcs[10];
7959 
7960   cli();
7961   cons.locking = 0;
7962   cprintf("cpu%d: panic: ", cpu->id);
7963   cprintf(s);
7964   cprintf("\n");
7965   getcallerpcs(&s, pcs);
7966   for(i=0; i<10; i++)
7967     cprintf(" %p", pcs[i]);
7968   panicked = 1; 
7969   for(;;)
7970     ;
7971 }
7972 
7973 
7974 
7975 
7976 
7977 
7978 
7979 
7980 
7981 
7982 
7983 
7984 
7985 
7986 
7987 
7988 
7989 
7990 
7991 
7992 
7993 
7994 
7995 
7996 
7997 
7998 
7999 
8000 #define BACKSPACE 0x100
8001 #define CRTPORT 0x3d4
8002 static ushort *crt = (ushort*)P2V(0xb8000);  
8003 
8004 static void
8005 cgaputc(int c)
8006 {
8007   int pos;
8008 
8009   
8010   outb(CRTPORT, 14);
8011   pos = inb(CRTPORT+1) << 8;
8012   outb(CRTPORT, 15);
8013   pos |= inb(CRTPORT+1);
8014 
8015   if(c == '\n')
8016     pos += 80 - pos%80;
8017   else if(c == BACKSPACE){
8018     if(pos > 0) --pos;
8019   } else
8020     crt[pos++] = (c&0xff) | 0x0700;  
8021 
8022   if((pos/80) >= 24){  
8023     memmove(crt, crt+80, sizeof(crt[0])*23*80);
8024     pos -= 80;
8025     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
8026   }
8027 
8028   outb(CRTPORT, 14);
8029   outb(CRTPORT+1, pos>>8);
8030   outb(CRTPORT, 15);
8031   outb(CRTPORT+1, pos);
8032   crt[pos] = ' ' | 0x0700;
8033 }
8034 
8035 void
8036 consputc(int c)
8037 {
8038   if(panicked){
8039     cli();
8040     for(;;)
8041       ;
8042   }
8043 
8044   if(c == BACKSPACE){
8045     uartputc('\b'); uartputc(' '); uartputc('\b');
8046   } else
8047     uartputc(c);
8048   cgaputc(c);
8049 }
8050 #define INPUT_BUF 128
8051 struct {
8052   struct spinlock lock;
8053   char buf[INPUT_BUF];
8054   uint r;  
8055   uint w;  
8056   uint e;  
8057 } input;
8058 
8059 #define C(x)  ((x)-'@')  
8060 
8061 void
8062 consoleintr(int (*getc)(void))
8063 {
8064   int c;
8065 
8066   acquire(&input.lock);
8067   while((c = getc()) >= 0){
8068     switch(c){
8069     case C('P'):  
8070       procdump();
8071       break;
8072     case C('U'):  
8073       while(input.e != input.w &&
8074             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
8075         input.e--;
8076         consputc(BACKSPACE);
8077       }
8078       break;
8079     case C('H'): case '\x7f':  
8080       if(input.e != input.w){
8081         input.e--;
8082         consputc(BACKSPACE);
8083       }
8084       break;
8085     default:
8086       if(c != 0 && input.e-input.r < INPUT_BUF){
8087         c = (c == '\r') ? '\n' : c;
8088         input.buf[input.e++ % INPUT_BUF] = c;
8089         consputc(c);
8090         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
8091           input.w = input.e;
8092           wakeup(&input.r);
8093         }
8094       }
8095       break;
8096     }
8097   }
8098   release(&input.lock);
8099 }
8100 int
8101 consoleread(struct inode *ip, char *dst, int n)
8102 {
8103   uint target;
8104   int c;
8105 
8106   iunlock(ip);
8107   target = n;
8108   acquire(&input.lock);
8109   while(n > 0){
8110     while(input.r == input.w){
8111       if(proc->killed){
8112         release(&input.lock);
8113         ilock(ip);
8114         return -1;
8115       }
8116       sleep(&input.r, &input.lock);
8117     }
8118     c = input.buf[input.r++ % INPUT_BUF];
8119     if(c == C('D')){  
8120       if(n < target){
8121         
8122         
8123         input.r--;
8124       }
8125       break;
8126     }
8127     *dst++ = c;
8128     --n;
8129     if(c == '\n')
8130       break;
8131   }
8132   release(&input.lock);
8133   ilock(ip);
8134 
8135   return target - n;
8136 }
8137 
8138 
8139 
8140 
8141 
8142 
8143 
8144 
8145 
8146 
8147 
8148 
8149 
8150 int
8151 consolewrite(struct inode *ip, char *buf, int n)
8152 {
8153   int i;
8154 
8155   iunlock(ip);
8156   acquire(&cons.lock);
8157   for(i = 0; i < n; i++)
8158     consputc(buf[i] & 0xff);
8159   release(&cons.lock);
8160   ilock(ip);
8161 
8162   return n;
8163 }
8164 
8165 void
8166 consoleinit(void)
8167 {
8168   initlock(&cons.lock, "console");
8169   initlock(&input.lock, "input");
8170 
8171   devsw[CONSOLE].write = consolewrite;
8172   devsw[CONSOLE].read = consoleread;
8173   cons.locking = 1;
8174 
8175   picenable(IRQ_KBD);
8176   ioapicenable(IRQ_KBD, 0);
8177 }
8178 
8179 
8180 
8181 
8182 
8183 
8184 
8185 
8186 
8187 
8188 
8189 
8190 
8191 
8192 
8193 
8194 
8195 
8196 
8197 
8198 
8199 
8200 
8201 
8202 
8203 
8204 #include "types.h"
8205 #include "defs.h"
8206 #include "traps.h"
8207 #include "x86.h"
8208 
8209 #define IO_TIMER1       0x040           
8210 
8211 
8212 
8213 
8214 
8215 #define TIMER_FREQ      1193182
8216 #define TIMER_DIV(x)    ((TIMER_FREQ+(x)/2)/(x))
8217 
8218 #define TIMER_MODE      (IO_TIMER1 + 3) 
8219 #define TIMER_SEL0      0x00    
8220 #define TIMER_RATEGEN   0x04    
8221 #define TIMER_16BIT     0x30    
8222 
8223 void
8224 timerinit(void)
8225 {
8226   
8227   outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
8228   outb(IO_TIMER1, TIMER_DIV(100) % 256);
8229   outb(IO_TIMER1, TIMER_DIV(100) / 256);
8230   picenable(IRQ_TIMER);
8231 }
8232 
8233 
8234 
8235 
8236 
8237 
8238 
8239 
8240 
8241 
8242 
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 
8251 
8252 #include "types.h"
8253 #include "defs.h"
8254 #include "param.h"
8255 #include "traps.h"
8256 #include "spinlock.h"
8257 #include "fs.h"
8258 #include "file.h"
8259 #include "mmu.h"
8260 #include "proc.h"
8261 #include "x86.h"
8262 
8263 #define COM1    0x3f8
8264 
8265 static int uart;    
8266 
8267 void
8268 uartinit(void)
8269 {
8270   char *p;
8271 
8272   
8273   outb(COM1+2, 0);
8274 
8275   
8276   outb(COM1+3, 0x80);    
8277   outb(COM1+0, 115200/9600);
8278   outb(COM1+1, 0);
8279   outb(COM1+3, 0x03);    
8280   outb(COM1+4, 0);
8281   outb(COM1+1, 0x01);    
8282 
8283   
8284   if(inb(COM1+5) == 0xFF)
8285     return;
8286   uart = 1;
8287 
8288   
8289   
8290   inb(COM1+2);
8291   inb(COM1+0);
8292   picenable(IRQ_COM1);
8293   ioapicenable(IRQ_COM1, 0);
8294 
8295   
8296   for(p="xv6...\n"; *p; p++)
8297     uartputc(*p);
8298 }
8299 
8300 void
8301 uartputc(int c)
8302 {
8303   int i;
8304 
8305   if(!uart)
8306     return;
8307   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
8308     microdelay(10);
8309   outb(COM1+0, c);
8310 }
8311 
8312 static int
8313 uartgetc(void)
8314 {
8315   if(!uart)
8316     return -1;
8317   if(!(inb(COM1+5) & 0x01))
8318     return -1;
8319   return inb(COM1+0);
8320 }
8321 
8322 void
8323 uartintr(void)
8324 {
8325   consoleintr(uartgetc);
8326 }
8327 
8328 
8329 
8330 
8331 
8332 
8333 
8334 
8335 
8336 
8337 
8338 
8339 
8340 
8341 
8342 
8343 
8344 
8345 
8346 
8347 
8348 
8349 
8350 
8351 
8352 
8353 
8354 
8355 
8356 
8357 .globl start
8358 start:
8359   pushl $argv
8360   pushl $init
8361   pushl $0  
8362   movl $SYS_exec, %eax
8363   int $T_SYSCALL
8364 
8365 
8366 exit:
8367   movl $SYS_exit, %eax
8368   int $T_SYSCALL
8369   jmp exit
8370 
8371 
8372 init:
8373   .string "/init\0"
8374 
8375 
8376 .p2align 2
8377 argv:
8378   .long init
8379   .long 0
8380 
8381 
8382 
8383 
8384 
8385 
8386 
8387 
8388 
8389 
8390 
8391 
8392 
8393 
8394 
8395 
8396 
8397 
8398 
8399 
8400 
8401 
8402 
8403 
8404   .globl name; \
8405   name: \
8406     movl $SYS_ 
8407     int $T_SYSCALL; \
8408     ret
8409 
8410 SYSCALL(fork)
8411 SYSCALL(exit)
8412 SYSCALL(wait)
8413 SYSCALL(pipe)
8414 SYSCALL(read)
8415 SYSCALL(write)
8416 SYSCALL(close)
8417 SYSCALL(kill)
8418 SYSCALL(exec)
8419 SYSCALL(open)
8420 SYSCALL(mknod)
8421 SYSCALL(unlink)
8422 SYSCALL(fstat)
8423 SYSCALL(link)
8424 SYSCALL(mkdir)
8425 SYSCALL(chdir)
8426 SYSCALL(dup)
8427 SYSCALL(getpid)
8428 SYSCALL(sbrk)
8429 SYSCALL(sleep)
8430 SYSCALL(uptime)
8431 SYSCALL(waitx)
8432 
8433 
8434 
8435 
8436 
8437 
8438 
8439 
8440 
8441 
8442 
8443 
8444 
8445 
8446 
8447 
8448 
8449 
8450 
8451 
8452 #include "types.h"
8453 #include "stat.h"
8454 #include "user.h"
8455 #include "fcntl.h"
8456 
8457 char *argv[] = { "sh", 0 };
8458 
8459 int
8460 main(void)
8461 {
8462   int pid, wpid;
8463 
8464   if(open("console", O_RDWR) < 0){
8465     mknod("console", 1, 1);
8466     open("console", O_RDWR);
8467   }
8468   dup(0);  
8469   dup(0);  
8470 
8471   for(;;){
8472     printf(1, "init: starting sh\n");
8473     pid = fork();
8474     if(pid < 0){
8475       printf(1, "init: fork failed\n");
8476       exit();
8477     }
8478     if(pid == 0){
8479       exec("sh", argv);
8480       printf(1, "init: exec sh failed\n");
8481       exit();
8482     }
8483     while((wpid=wait()) >= 0 && wpid != pid)
8484       printf(1, "zombie!\n");
8485   }
8486 }
8487 
8488 
8489 
8490 
8491 
8492 
8493 
8494 
8495 
8496 
8497 
8498 
8499 
8500 
8501 
8502 #include "types.h"
8503 #include "user.h"
8504 #include "fcntl.h"
8505 
8506 
8507 #define EXEC  1
8508 #define REDIR 2
8509 #define PIPE  3
8510 #define LIST  4
8511 #define BACK  5
8512 
8513 #define MAXARGS 10
8514 
8515 struct cmd {
8516   int type;
8517 };
8518 
8519 struct execcmd {
8520   int type;
8521   char *argv[MAXARGS];
8522   char *eargv[MAXARGS];
8523 };
8524 
8525 struct redircmd {
8526   int type;
8527   struct cmd *cmd;
8528   char *file;
8529   char *efile;
8530   int mode;
8531   int fd;
8532 };
8533 
8534 struct pipecmd {
8535   int type;
8536   struct cmd *left;
8537   struct cmd *right;
8538 };
8539 
8540 struct listcmd {
8541   int type;
8542   struct cmd *left;
8543   struct cmd *right;
8544 };
8545 
8546 struct backcmd {
8547   int type;
8548   struct cmd *cmd;
8549 };
8550 int fork1(void);  
8551 void panic(char*);
8552 struct cmd *parsecmd(char*);
8553 
8554 
8555 void
8556 runcmd(struct cmd *cmd)
8557 {
8558   int p[2];
8559   struct backcmd *bcmd;
8560   struct execcmd *ecmd;
8561   struct listcmd *lcmd;
8562   struct pipecmd *pcmd;
8563   struct redircmd *rcmd;
8564 
8565   if(cmd == 0)
8566     exit();
8567 
8568   switch(cmd->type){
8569   default:
8570     panic("runcmd");
8571 
8572   case EXEC:
8573     ecmd = (struct execcmd*)cmd;
8574     if(ecmd->argv[0] == 0)
8575       exit();
8576     exec(ecmd->argv[0], ecmd->argv);
8577     printf(2, "exec %s failed\n", ecmd->argv[0]);
8578     break;
8579 
8580   case REDIR:
8581     rcmd = (struct redircmd*)cmd;
8582     close(rcmd->fd);
8583     if(open(rcmd->file, rcmd->mode) < 0){
8584       printf(2, "open %s failed\n", rcmd->file);
8585       exit();
8586     }
8587     runcmd(rcmd->cmd);
8588     break;
8589 
8590   case LIST:
8591     lcmd = (struct listcmd*)cmd;
8592     if(fork1() == 0)
8593       runcmd(lcmd->left);
8594     wait();
8595     runcmd(lcmd->right);
8596     break;
8597 
8598 
8599 
8600   case PIPE:
8601     pcmd = (struct pipecmd*)cmd;
8602     if(pipe(p) < 0)
8603       panic("pipe");
8604     if(fork1() == 0){
8605       close(1);
8606       dup(p[1]);
8607       close(p[0]);
8608       close(p[1]);
8609       runcmd(pcmd->left);
8610     }
8611     if(fork1() == 0){
8612       close(0);
8613       dup(p[0]);
8614       close(p[0]);
8615       close(p[1]);
8616       runcmd(pcmd->right);
8617     }
8618     close(p[0]);
8619     close(p[1]);
8620     wait();
8621     wait();
8622     break;
8623 
8624   case BACK:
8625     bcmd = (struct backcmd*)cmd;
8626     if(fork1() == 0)
8627       runcmd(bcmd->cmd);
8628     break;
8629   }
8630   exit();
8631 }
8632 
8633 int
8634 getcmd(char *buf, int nbuf)
8635 {
8636   printf(2, "$ ");
8637   memset(buf, 0, nbuf);
8638   gets(buf, nbuf);
8639   if(buf[0] == 0) 
8640     return -1;
8641   return 0;
8642 }
8643 
8644 
8645 
8646 
8647 
8648 
8649 
8650 int
8651 main(void)
8652 {
8653   static char buf[100];
8654   int fd;
8655 
8656   
8657   while((fd = open("console", O_RDWR)) >= 0){
8658     if(fd >= 3){
8659       close(fd);
8660       break;
8661     }
8662   }
8663 
8664   
8665   while(getcmd(buf, sizeof(buf)) >= 0){
8666     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
8667       
8668       
8669       buf[strlen(buf)-1] = 0;  
8670       if(chdir(buf+3) < 0)
8671         printf(2, "cannot cd %s\n", buf+3);
8672       continue;
8673     }
8674     if(fork1() == 0)
8675       runcmd(parsecmd(buf));
8676     wait();
8677   }
8678   exit();
8679 }
8680 
8681 void
8682 panic(char *s)
8683 {
8684   printf(2, "%s\n", s);
8685   exit();
8686 }
8687 
8688 int
8689 fork1(void)
8690 {
8691   int pid;
8692 
8693   pid = fork();
8694   if(pid == -1)
8695     panic("fork");
8696   return pid;
8697 }
8698 
8699 
8700 
8701 
8702 struct cmd*
8703 execcmd(void)
8704 {
8705   struct execcmd *cmd;
8706 
8707   cmd = malloc(sizeof(*cmd));
8708   memset(cmd, 0, sizeof(*cmd));
8709   cmd->type = EXEC;
8710   return (struct cmd*)cmd;
8711 }
8712 
8713 struct cmd*
8714 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
8715 {
8716   struct redircmd *cmd;
8717 
8718   cmd = malloc(sizeof(*cmd));
8719   memset(cmd, 0, sizeof(*cmd));
8720   cmd->type = REDIR;
8721   cmd->cmd = subcmd;
8722   cmd->file = file;
8723   cmd->efile = efile;
8724   cmd->mode = mode;
8725   cmd->fd = fd;
8726   return (struct cmd*)cmd;
8727 }
8728 
8729 struct cmd*
8730 pipecmd(struct cmd *left, struct cmd *right)
8731 {
8732   struct pipecmd *cmd;
8733 
8734   cmd = malloc(sizeof(*cmd));
8735   memset(cmd, 0, sizeof(*cmd));
8736   cmd->type = PIPE;
8737   cmd->left = left;
8738   cmd->right = right;
8739   return (struct cmd*)cmd;
8740 }
8741 
8742 
8743 
8744 
8745 
8746 
8747 
8748 
8749 
8750 struct cmd*
8751 listcmd(struct cmd *left, struct cmd *right)
8752 {
8753   struct listcmd *cmd;
8754 
8755   cmd = malloc(sizeof(*cmd));
8756   memset(cmd, 0, sizeof(*cmd));
8757   cmd->type = LIST;
8758   cmd->left = left;
8759   cmd->right = right;
8760   return (struct cmd*)cmd;
8761 }
8762 
8763 struct cmd*
8764 backcmd(struct cmd *subcmd)
8765 {
8766   struct backcmd *cmd;
8767 
8768   cmd = malloc(sizeof(*cmd));
8769   memset(cmd, 0, sizeof(*cmd));
8770   cmd->type = BACK;
8771   cmd->cmd = subcmd;
8772   return (struct cmd*)cmd;
8773 }
8774 
8775 
8776 
8777 
8778 
8779 
8780 
8781 
8782 
8783 
8784 
8785 
8786 
8787 
8788 
8789 
8790 
8791 
8792 
8793 
8794 
8795 
8796 
8797 
8798 
8799 
8800 
8801 
8802 char whitespace[] = " \t\r\n\v";
8803 char symbols[] = "<|>&;()";
8804 
8805 int
8806 gettoken(char **ps, char *es, char **q, char **eq)
8807 {
8808   char *s;
8809   int ret;
8810 
8811   s = *ps;
8812   while(s < es && strchr(whitespace, *s))
8813     s++;
8814   if(q)
8815     *q = s;
8816   ret = *s;
8817   switch(*s){
8818   case 0:
8819     break;
8820   case '|':
8821   case '(':
8822   case ')':
8823   case ';':
8824   case '&':
8825   case '<':
8826     s++;
8827     break;
8828   case '>':
8829     s++;
8830     if(*s == '>'){
8831       ret = '+';
8832       s++;
8833     }
8834     break;
8835   default:
8836     ret = 'a';
8837     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
8838       s++;
8839     break;
8840   }
8841   if(eq)
8842     *eq = s;
8843 
8844   while(s < es && strchr(whitespace, *s))
8845     s++;
8846   *ps = s;
8847   return ret;
8848 }
8849 
8850 int
8851 peek(char **ps, char *es, char *toks)
8852 {
8853   char *s;
8854 
8855   s = *ps;
8856   while(s < es && strchr(whitespace, *s))
8857     s++;
8858   *ps = s;
8859   return *s && strchr(toks, *s);
8860 }
8861 
8862 struct cmd *parseline(char**, char*);
8863 struct cmd *parsepipe(char**, char*);
8864 struct cmd *parseexec(char**, char*);
8865 struct cmd *nulterminate(struct cmd*);
8866 
8867 struct cmd*
8868 parsecmd(char *s)
8869 {
8870   char *es;
8871   struct cmd *cmd;
8872 
8873   es = s + strlen(s);
8874   cmd = parseline(&s, es);
8875   peek(&s, es, "");
8876   if(s != es){
8877     printf(2, "leftovers: %s\n", s);
8878     panic("syntax");
8879   }
8880   nulterminate(cmd);
8881   return cmd;
8882 }
8883 
8884 struct cmd*
8885 parseline(char **ps, char *es)
8886 {
8887   struct cmd *cmd;
8888 
8889   cmd = parsepipe(ps, es);
8890   while(peek(ps, es, "&")){
8891     gettoken(ps, es, 0, 0);
8892     cmd = backcmd(cmd);
8893   }
8894   if(peek(ps, es, ";")){
8895     gettoken(ps, es, 0, 0);
8896     cmd = listcmd(cmd, parseline(ps, es));
8897   }
8898   return cmd;
8899 }
8900 struct cmd*
8901 parsepipe(char **ps, char *es)
8902 {
8903   struct cmd *cmd;
8904 
8905   cmd = parseexec(ps, es);
8906   if(peek(ps, es, "|")){
8907     gettoken(ps, es, 0, 0);
8908     cmd = pipecmd(cmd, parsepipe(ps, es));
8909   }
8910   return cmd;
8911 }
8912 
8913 struct cmd*
8914 parseredirs(struct cmd *cmd, char **ps, char *es)
8915 {
8916   int tok;
8917   char *q, *eq;
8918 
8919   while(peek(ps, es, "<>")){
8920     tok = gettoken(ps, es, 0, 0);
8921     if(gettoken(ps, es, &q, &eq) != 'a')
8922       panic("missing file for redirection");
8923     switch(tok){
8924     case '<':
8925       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
8926       break;
8927     case '>':
8928       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8929       break;
8930     case '+':  
8931       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8932       break;
8933     }
8934   }
8935   return cmd;
8936 }
8937 
8938 
8939 
8940 
8941 
8942 
8943 
8944 
8945 
8946 
8947 
8948 
8949 
8950 struct cmd*
8951 parseblock(char **ps, char *es)
8952 {
8953   struct cmd *cmd;
8954 
8955   if(!peek(ps, es, "("))
8956     panic("parseblock");
8957   gettoken(ps, es, 0, 0);
8958   cmd = parseline(ps, es);
8959   if(!peek(ps, es, ")"))
8960     panic("syntax - missing )");
8961   gettoken(ps, es, 0, 0);
8962   cmd = parseredirs(cmd, ps, es);
8963   return cmd;
8964 }
8965 
8966 struct cmd*
8967 parseexec(char **ps, char *es)
8968 {
8969   char *q, *eq;
8970   int tok, argc;
8971   struct execcmd *cmd;
8972   struct cmd *ret;
8973 
8974   if(peek(ps, es, "("))
8975     return parseblock(ps, es);
8976 
8977   ret = execcmd();
8978   cmd = (struct execcmd*)ret;
8979 
8980   argc = 0;
8981   ret = parseredirs(ret, ps, es);
8982   while(!peek(ps, es, "|)&;")){
8983     if((tok=gettoken(ps, es, &q, &eq)) == 0)
8984       break;
8985     if(tok != 'a')
8986       panic("syntax");
8987     cmd->argv[argc] = q;
8988     cmd->eargv[argc] = eq;
8989     argc++;
8990     if(argc >= MAXARGS)
8991       panic("too many args");
8992     ret = parseredirs(ret, ps, es);
8993   }
8994   cmd->argv[argc] = 0;
8995   cmd->eargv[argc] = 0;
8996   return ret;
8997 }
8998 
8999 
9000 
9001 struct cmd*
9002 nulterminate(struct cmd *cmd)
9003 {
9004   int i;
9005   struct backcmd *bcmd;
9006   struct execcmd *ecmd;
9007   struct listcmd *lcmd;
9008   struct pipecmd *pcmd;
9009   struct redircmd *rcmd;
9010 
9011   if(cmd == 0)
9012     return 0;
9013 
9014   switch(cmd->type){
9015   case EXEC:
9016     ecmd = (struct execcmd*)cmd;
9017     for(i=0; ecmd->argv[i]; i++)
9018       *ecmd->eargv[i] = 0;
9019     break;
9020 
9021   case REDIR:
9022     rcmd = (struct redircmd*)cmd;
9023     nulterminate(rcmd->cmd);
9024     *rcmd->efile = 0;
9025     break;
9026 
9027   case PIPE:
9028     pcmd = (struct pipecmd*)cmd;
9029     nulterminate(pcmd->left);
9030     nulterminate(pcmd->right);
9031     break;
9032 
9033   case LIST:
9034     lcmd = (struct listcmd*)cmd;
9035     nulterminate(lcmd->left);
9036     nulterminate(lcmd->right);
9037     break;
9038 
9039   case BACK:
9040     bcmd = (struct backcmd*)cmd;
9041     nulterminate(bcmd->cmd);
9042     break;
9043   }
9044   return cmd;
9045 }
9046 
9047 
9048 
9049 
9050 
9051 
9052 
9053 
9054 
9055 
9056 
9057 
9058 
9059 .code16                       
9060 .globl start
9061 start:
9062   cli                         
9063 
9064   
9065   xorw    %ax,%ax             
9066   movw    %ax,%ds             
9067   movw    %ax,%es             
9068   movw    %ax,%ss             
9069 
9070   
9071   
9072 seta20.1:
9073   inb     $0x64,%al               
9074   testb   $0x2,%al
9075   jnz     seta20.1
9076 
9077   movb    $0xd1,%al               
9078   outb    %al,$0x64
9079 
9080 seta20.2:
9081   inb     $0x64,%al               
9082   testb   $0x2,%al
9083   jnz     seta20.2
9084 
9085   movb    $0xdf,%al               
9086   outb    %al,$0x60
9087 
9088   
9089   
9090   
9091   lgdt    gdtdesc
9092   movl    %cr0, %eax
9093   orl     $CR0_PE, %eax
9094   movl    %eax, %cr0
9095 
9096 
9097 
9098 
9099 
9100   
9101   
9102   
9103   ljmp    $(SEG_KCODE<<3), $start32
9104 
9105 .code32  
9106 start32:
9107   
9108   movw    $(SEG_KDATA<<3), %ax    
9109   movw    %ax, %ds                
9110   movw    %ax, %es                
9111   movw    %ax, %ss                
9112   movw    $0, %ax                 
9113   movw    %ax, %fs                
9114   movw    %ax, %gs                
9115 
9116   
9117   movl    $start, %esp
9118   call    bootmain
9119 
9120   
9121   
9122   movw    $0x8a00, %ax            
9123   movw    %ax, %dx
9124   outw    %ax, %dx
9125   movw    $0x8ae0, %ax            
9126   outw    %ax, %dx
9127 spin:
9128   jmp     spin
9129 
9130 
9131 .p2align 2                                
9132 gdt:
9133   SEG_NULLASM                             
9134   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
9135   SEG_ASM(STA_W, 0x0, 0xffffffff)         
9136 
9137 gdtdesc:
9138   .word   (gdtdesc - gdt - 1)             
9139   .long   gdt                             
9140 
9141 
9142 
9143 
9144 
9145 
9146 
9147 
9148 
9149 
9150 
9151 
9152 
9153 
9154 
9155 
9156 
9157 #include "types.h"
9158 #include "elf.h"
9159 #include "x86.h"
9160 #include "memlayout.h"
9161 
9162 #define SECTSIZE  512
9163 
9164 void readseg(uchar*, uint, uint);
9165 
9166 void
9167 bootmain(void)
9168 {
9169   struct elfhdr *elf;
9170   struct proghdr *ph, *eph;
9171   void (*entry)(void);
9172   uchar* pa;
9173 
9174   elf = (struct elfhdr*)0x10000;  
9175 
9176   
9177   readseg((uchar*)elf, 4096, 0);
9178 
9179   
9180   if(elf->magic != ELF_MAGIC)
9181     return;  
9182 
9183   
9184   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
9185   eph = ph + elf->phnum;
9186   for(; ph < eph; ph++){
9187     pa = (uchar*)ph->paddr;
9188     readseg(pa, ph->filesz, ph->off);
9189     if(ph->memsz > ph->filesz)
9190       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
9191   }
9192 
9193   
9194   
9195   entry = (void(*)(void))(elf->entry);
9196   entry();
9197 }
9198 
9199 
9200 void
9201 waitdisk(void)
9202 {
9203   
9204   while((inb(0x1F7) & 0xC0) != 0x40)
9205     ;
9206 }
9207 
9208 
9209 void
9210 readsect(void *dst, uint offset)
9211 {
9212   
9213   waitdisk();
9214   outb(0x1F2, 1);   
9215   outb(0x1F3, offset);
9216   outb(0x1F4, offset >> 8);
9217   outb(0x1F5, offset >> 16);
9218   outb(0x1F6, (offset >> 24) | 0xE0);
9219   outb(0x1F7, 0x20);  
9220 
9221   
9222   waitdisk();
9223   insl(0x1F0, dst, SECTSIZE/4);
9224 }
9225 
9226 
9227 
9228 void
9229 readseg(uchar* pa, uint count, uint offset)
9230 {
9231   uchar* epa;
9232 
9233   epa = pa + count;
9234 
9235   
9236   pa -= offset % SECTSIZE;
9237 
9238   
9239   offset = (offset / SECTSIZE) + 1;
9240 
9241   
9242   
9243   
9244   for(; pa < epa; pa += SECTSIZE, offset++)
9245     readsect(pa, offset);
9246 }
9247 
9248 
9249 
